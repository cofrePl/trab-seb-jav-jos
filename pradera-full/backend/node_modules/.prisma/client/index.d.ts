
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Worker
 * 
 */
export type Worker = $Result.DefaultSelection<Prisma.$WorkerPayload>
/**
 * Model Crew
 * 
 */
export type Crew = $Result.DefaultSelection<Prisma.$CrewPayload>
/**
 * Model CrewWorker
 * 
 */
export type CrewWorker = $Result.DefaultSelection<Prisma.$CrewWorkerPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model MaterialRequest
 * 
 */
export type MaterialRequest = $Result.DefaultSelection<Prisma.$MaterialRequestPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model CommunicationRequest
 * 
 */
export type CommunicationRequest = $Result.DefaultSelection<Prisma.$CommunicationRequestPayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  JEFE_PROYECTO: 'JEFE_PROYECTO',
  LIDER_CUADRILLA: 'LIDER_CUADRILLA',
  TRABAJADOR: 'TRABAJADOR'
};

export type Role = (typeof Role)[keyof typeof Role]


export const CrewState: {
  ACTIVA: 'ACTIVA',
  EN_PAUSA: 'EN_PAUSA',
  FINALIZADA: 'FINALIZADA'
};

export type CrewState = (typeof CrewState)[keyof typeof CrewState]


export const MaterialRequestState: {
  PENDIENTE: 'PENDIENTE',
  ASIGNADO: 'ASIGNADO',
  AGOTADO: 'AGOTADO',
  COMPLETADO: 'COMPLETADO'
};

export type MaterialRequestState = (typeof MaterialRequestState)[keyof typeof MaterialRequestState]


export const RequestType: {
  MATERIAL: 'MATERIAL',
  HERRAMIENTA: 'HERRAMIENTA',
  APOYO: 'APOYO',
  PERMISO: 'PERMISO'
};

export type RequestType = (typeof RequestType)[keyof typeof RequestType]


export const RequestStatus: {
  PENDIENTE: 'PENDIENTE',
  APROBADA: 'APROBADA',
  RECHAZADA: 'RECHAZADA'
};

export type RequestStatus = (typeof RequestStatus)[keyof typeof RequestStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type CrewState = $Enums.CrewState

export const CrewState: typeof $Enums.CrewState

export type MaterialRequestState = $Enums.MaterialRequestState

export const MaterialRequestState: typeof $Enums.MaterialRequestState

export type RequestType = $Enums.RequestType

export const RequestType: typeof $Enums.RequestType

export type RequestStatus = $Enums.RequestStatus

export const RequestStatus: typeof $Enums.RequestStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.worker`: Exposes CRUD operations for the **Worker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workers
    * const workers = await prisma.worker.findMany()
    * ```
    */
  get worker(): Prisma.WorkerDelegate<ExtArgs>;

  /**
   * `prisma.crew`: Exposes CRUD operations for the **Crew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crews
    * const crews = await prisma.crew.findMany()
    * ```
    */
  get crew(): Prisma.CrewDelegate<ExtArgs>;

  /**
   * `prisma.crewWorker`: Exposes CRUD operations for the **CrewWorker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrewWorkers
    * const crewWorkers = await prisma.crewWorker.findMany()
    * ```
    */
  get crewWorker(): Prisma.CrewWorkerDelegate<ExtArgs>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs>;

  /**
   * `prisma.materialRequest`: Exposes CRUD operations for the **MaterialRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialRequests
    * const materialRequests = await prisma.materialRequest.findMany()
    * ```
    */
  get materialRequest(): Prisma.MaterialRequestDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.communicationRequest`: Exposes CRUD operations for the **CommunicationRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunicationRequests
    * const communicationRequests = await prisma.communicationRequest.findMany()
    * ```
    */
  get communicationRequest(): Prisma.CommunicationRequestDelegate<ExtArgs>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Project: 'Project',
    Worker: 'Worker',
    Crew: 'Crew',
    CrewWorker: 'CrewWorker',
    Log: 'Log',
    Material: 'Material',
    MaterialRequest: 'MaterialRequest',
    Message: 'Message',
    CommunicationRequest: 'CommunicationRequest',
    Certificate: 'Certificate',
    Milestone: 'Milestone',
    Task: 'Task',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "project" | "worker" | "crew" | "crewWorker" | "log" | "material" | "materialRequest" | "message" | "communicationRequest" | "certificate" | "milestone" | "task" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Worker: {
        payload: Prisma.$WorkerPayload<ExtArgs>
        fields: Prisma.WorkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findFirst: {
            args: Prisma.WorkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findMany: {
            args: Prisma.WorkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          create: {
            args: Prisma.WorkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          createMany: {
            args: Prisma.WorkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          delete: {
            args: Prisma.WorkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          update: {
            args: Prisma.WorkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          deleteMany: {
            args: Prisma.WorkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          aggregate: {
            args: Prisma.WorkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorker>
          }
          groupBy: {
            args: Prisma.WorkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerCountAggregateOutputType> | number
          }
        }
      }
      Crew: {
        payload: Prisma.$CrewPayload<ExtArgs>
        fields: Prisma.CrewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          findFirst: {
            args: Prisma.CrewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          findMany: {
            args: Prisma.CrewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>[]
          }
          create: {
            args: Prisma.CrewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          createMany: {
            args: Prisma.CrewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>[]
          }
          delete: {
            args: Prisma.CrewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          update: {
            args: Prisma.CrewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          deleteMany: {
            args: Prisma.CrewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CrewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          aggregate: {
            args: Prisma.CrewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrew>
          }
          groupBy: {
            args: Prisma.CrewGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrewGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewCountArgs<ExtArgs>
            result: $Utils.Optional<CrewCountAggregateOutputType> | number
          }
        }
      }
      CrewWorker: {
        payload: Prisma.$CrewWorkerPayload<ExtArgs>
        fields: Prisma.CrewWorkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewWorkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewWorkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewWorkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewWorkerPayload>
          }
          findFirst: {
            args: Prisma.CrewWorkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewWorkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewWorkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewWorkerPayload>
          }
          findMany: {
            args: Prisma.CrewWorkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewWorkerPayload>[]
          }
          create: {
            args: Prisma.CrewWorkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewWorkerPayload>
          }
          createMany: {
            args: Prisma.CrewWorkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrewWorkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewWorkerPayload>[]
          }
          delete: {
            args: Prisma.CrewWorkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewWorkerPayload>
          }
          update: {
            args: Prisma.CrewWorkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewWorkerPayload>
          }
          deleteMany: {
            args: Prisma.CrewWorkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrewWorkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CrewWorkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewWorkerPayload>
          }
          aggregate: {
            args: Prisma.CrewWorkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrewWorker>
          }
          groupBy: {
            args: Prisma.CrewWorkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrewWorkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewWorkerCountArgs<ExtArgs>
            result: $Utils.Optional<CrewWorkerCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      MaterialRequest: {
        payload: Prisma.$MaterialRequestPayload<ExtArgs>
        fields: Prisma.MaterialRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>
          }
          findFirst: {
            args: Prisma.MaterialRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>
          }
          findMany: {
            args: Prisma.MaterialRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>[]
          }
          create: {
            args: Prisma.MaterialRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>
          }
          createMany: {
            args: Prisma.MaterialRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>[]
          }
          delete: {
            args: Prisma.MaterialRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>
          }
          update: {
            args: Prisma.MaterialRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>
          }
          deleteMany: {
            args: Prisma.MaterialRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialRequestPayload>
          }
          aggregate: {
            args: Prisma.MaterialRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialRequest>
          }
          groupBy: {
            args: Prisma.MaterialRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialRequestCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      CommunicationRequest: {
        payload: Prisma.$CommunicationRequestPayload<ExtArgs>
        fields: Prisma.CommunicationRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunicationRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunicationRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationRequestPayload>
          }
          findFirst: {
            args: Prisma.CommunicationRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunicationRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationRequestPayload>
          }
          findMany: {
            args: Prisma.CommunicationRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationRequestPayload>[]
          }
          create: {
            args: Prisma.CommunicationRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationRequestPayload>
          }
          createMany: {
            args: Prisma.CommunicationRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunicationRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationRequestPayload>[]
          }
          delete: {
            args: Prisma.CommunicationRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationRequestPayload>
          }
          update: {
            args: Prisma.CommunicationRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationRequestPayload>
          }
          deleteMany: {
            args: Prisma.CommunicationRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunicationRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunicationRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationRequestPayload>
          }
          aggregate: {
            args: Prisma.CommunicationRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunicationRequest>
          }
          groupBy: {
            args: Prisma.CommunicationRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunicationRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunicationRequestCountArgs<ExtArgs>
            result: $Utils.Optional<CommunicationRequestCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    projects: number
    logs: number
    sentMessages: number
    receivedMessages: number
    requests: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    requests?: boolean | UserCountOutputTypeCountRequestsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationRequestWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    crews: number
    materialRequests: number
    logs: number
    milestones: number
    auditLogs: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crews?: boolean | ProjectCountOutputTypeCountCrewsArgs
    materialRequests?: boolean | ProjectCountOutputTypeCountMaterialRequestsArgs
    logs?: boolean | ProjectCountOutputTypeCountLogsArgs
    milestones?: boolean | ProjectCountOutputTypeCountMilestonesArgs
    auditLogs?: boolean | ProjectCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCrewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMaterialRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequestWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type WorkerCountOutputType
   */

  export type WorkerCountOutputType = {
    crewWorkers: number
    certificates: number
  }

  export type WorkerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crewWorkers?: boolean | WorkerCountOutputTypeCountCrewWorkersArgs
    certificates?: boolean | WorkerCountOutputTypeCountCertificatesArgs
  }

  // Custom InputTypes
  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerCountOutputType
     */
    select?: WorkerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeCountCrewWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWorkerWhereInput
  }

  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Count Type CrewCountOutputType
   */

  export type CrewCountOutputType = {
    crewWorkers: number
    logs: number
    materialRequests: number
    communicationRequests: number
    tasks: number
  }

  export type CrewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crewWorkers?: boolean | CrewCountOutputTypeCountCrewWorkersArgs
    logs?: boolean | CrewCountOutputTypeCountLogsArgs
    materialRequests?: boolean | CrewCountOutputTypeCountMaterialRequestsArgs
    communicationRequests?: boolean | CrewCountOutputTypeCountCommunicationRequestsArgs
    tasks?: boolean | CrewCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewCountOutputType
     */
    select?: CrewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountCrewWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWorkerWhereInput
  }

  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountMaterialRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequestWhereInput
  }

  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountCommunicationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationRequestWhereInput
  }

  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type MaterialCountOutputType
   */

  export type MaterialCountOutputType = {
    requests: number
  }

  export type MaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requests?: boolean | MaterialCountOutputTypeCountRequestsArgs
  }

  // Custom InputTypes
  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCountOutputType
     */
    select?: MaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequestWhereInput
  }


  /**
   * Count Type CertificateCountOutputType
   */

  export type CertificateCountOutputType = {
    workers: number
  }

  export type CertificateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workers?: boolean | CertificateCountOutputTypeCountWorkersArgs
  }

  // Custom InputTypes
  /**
   * CertificateCountOutputType without action
   */
  export type CertificateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateCountOutputType
     */
    select?: CertificateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CertificateCountOutputType without action
   */
  export type CertificateCountOutputTypeCountWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    projects?: boolean | User$projectsArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    requests?: boolean | User$requestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | User$projectsArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    requests?: boolean | User$requestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      requests: Prisma.$CommunicationRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: $Enums.Role
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany"> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    requests<T extends User$requestsArgs<ExtArgs> = {}>(args?: Subset<T, User$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.requests
   */
  export type User$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestInclude<ExtArgs> | null
    where?: CommunicationRequestWhereInput
    orderBy?: CommunicationRequestOrderByWithRelationInput | CommunicationRequestOrderByWithRelationInput[]
    cursor?: CommunicationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationRequestScalarFieldEnum | CommunicationRequestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    duracion_estimada: number | null
    presupuesto: number | null
  }

  export type ProjectSumAggregateOutputType = {
    duracion_estimada: number | null
    presupuesto: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    tipo_obra: string | null
    complejidad: string | null
    duracion_estimada: number | null
    fecha_inicio: Date | null
    fecha_termino: Date | null
    zona_trabajo: string | null
    estado: string | null
    presupuesto: number | null
    supervisor: string | null
    descripcion_tecnica: string | null
    jefeId: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    tipo_obra: string | null
    complejidad: string | null
    duracion_estimada: number | null
    fecha_inicio: Date | null
    fecha_termino: Date | null
    zona_trabajo: string | null
    estado: string | null
    presupuesto: number | null
    supervisor: string | null
    descripcion_tecnica: string | null
    jefeId: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    tipo_obra: number
    complejidad: number
    duracion_estimada: number
    fecha_inicio: number
    fecha_termino: number
    zona_trabajo: number
    estado: number
    presupuesto: number
    supervisor: number
    descripcion_tecnica: number
    jefeId: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    duracion_estimada?: true
    presupuesto?: true
  }

  export type ProjectSumAggregateInputType = {
    duracion_estimada?: true
    presupuesto?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    tipo_obra?: true
    complejidad?: true
    duracion_estimada?: true
    fecha_inicio?: true
    fecha_termino?: true
    zona_trabajo?: true
    estado?: true
    presupuesto?: true
    supervisor?: true
    descripcion_tecnica?: true
    jefeId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    tipo_obra?: true
    complejidad?: true
    duracion_estimada?: true
    fecha_inicio?: true
    fecha_termino?: true
    zona_trabajo?: true
    estado?: true
    presupuesto?: true
    supervisor?: true
    descripcion_tecnica?: true
    jefeId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    tipo_obra?: true
    complejidad?: true
    duracion_estimada?: true
    fecha_inicio?: true
    fecha_termino?: true
    zona_trabajo?: true
    estado?: true
    presupuesto?: true
    supervisor?: true
    descripcion_tecnica?: true
    jefeId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada: number | null
    fecha_inicio: Date | null
    fecha_termino: Date | null
    zona_trabajo: string
    estado: string
    presupuesto: number | null
    supervisor: string | null
    descripcion_tecnica: string | null
    jefeId: string | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tipo_obra?: boolean
    complejidad?: boolean
    duracion_estimada?: boolean
    fecha_inicio?: boolean
    fecha_termino?: boolean
    zona_trabajo?: boolean
    estado?: boolean
    presupuesto?: boolean
    supervisor?: boolean
    descripcion_tecnica?: boolean
    jefeId?: boolean
    jefe?: boolean | Project$jefeArgs<ExtArgs>
    crews?: boolean | Project$crewsArgs<ExtArgs>
    materialRequests?: boolean | Project$materialRequestsArgs<ExtArgs>
    logs?: boolean | Project$logsArgs<ExtArgs>
    milestones?: boolean | Project$milestonesArgs<ExtArgs>
    auditLogs?: boolean | Project$auditLogsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tipo_obra?: boolean
    complejidad?: boolean
    duracion_estimada?: boolean
    fecha_inicio?: boolean
    fecha_termino?: boolean
    zona_trabajo?: boolean
    estado?: boolean
    presupuesto?: boolean
    supervisor?: boolean
    descripcion_tecnica?: boolean
    jefeId?: boolean
    jefe?: boolean | Project$jefeArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    tipo_obra?: boolean
    complejidad?: boolean
    duracion_estimada?: boolean
    fecha_inicio?: boolean
    fecha_termino?: boolean
    zona_trabajo?: boolean
    estado?: boolean
    presupuesto?: boolean
    supervisor?: boolean
    descripcion_tecnica?: boolean
    jefeId?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jefe?: boolean | Project$jefeArgs<ExtArgs>
    crews?: boolean | Project$crewsArgs<ExtArgs>
    materialRequests?: boolean | Project$materialRequestsArgs<ExtArgs>
    logs?: boolean | Project$logsArgs<ExtArgs>
    milestones?: boolean | Project$milestonesArgs<ExtArgs>
    auditLogs?: boolean | Project$auditLogsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jefe?: boolean | Project$jefeArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      jefe: Prisma.$UserPayload<ExtArgs> | null
      crews: Prisma.$CrewPayload<ExtArgs>[]
      materialRequests: Prisma.$MaterialRequestPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      tipo_obra: string
      complejidad: string
      duracion_estimada: number | null
      fecha_inicio: Date | null
      fecha_termino: Date | null
      zona_trabajo: string
      estado: string
      presupuesto: number | null
      supervisor: string | null
      descripcion_tecnica: string | null
      jefeId: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jefe<T extends Project$jefeArgs<ExtArgs> = {}>(args?: Subset<T, Project$jefeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    crews<T extends Project$crewsArgs<ExtArgs> = {}>(args?: Subset<T, Project$crewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findMany"> | Null>
    materialRequests<T extends Project$materialRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Project$materialRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends Project$logsArgs<ExtArgs> = {}>(args?: Subset<T, Project$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany"> | Null>
    milestones<T extends Project$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Project$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Project$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Project$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly tipo_obra: FieldRef<"Project", 'String'>
    readonly complejidad: FieldRef<"Project", 'String'>
    readonly duracion_estimada: FieldRef<"Project", 'Int'>
    readonly fecha_inicio: FieldRef<"Project", 'DateTime'>
    readonly fecha_termino: FieldRef<"Project", 'DateTime'>
    readonly zona_trabajo: FieldRef<"Project", 'String'>
    readonly estado: FieldRef<"Project", 'String'>
    readonly presupuesto: FieldRef<"Project", 'Float'>
    readonly supervisor: FieldRef<"Project", 'String'>
    readonly descripcion_tecnica: FieldRef<"Project", 'String'>
    readonly jefeId: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.jefe
   */
  export type Project$jefeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.crews
   */
  export type Project$crewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    cursor?: CrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Project.materialRequests
   */
  export type Project$materialRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    where?: MaterialRequestWhereInput
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    cursor?: MaterialRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialRequestScalarFieldEnum | MaterialRequestScalarFieldEnum[]
  }

  /**
   * Project.logs
   */
  export type Project$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Project.milestones
   */
  export type Project$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Project.auditLogs
   */
  export type Project$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Worker
   */

  export type AggregateWorker = {
    _count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  export type WorkerAvgAggregateOutputType = {
    experiencia: number | null
  }

  export type WorkerSumAggregateOutputType = {
    experiencia: number | null
  }

  export type WorkerMinAggregateOutputType = {
    id: string | null
    name: string | null
    rut: string | null
    especialidad: string | null
    certificaciones: string | null
    experiencia: number | null
    disponibilidad: boolean | null
    estado: string | null
    zona_preferencia: string | null
  }

  export type WorkerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    rut: string | null
    especialidad: string | null
    certificaciones: string | null
    experiencia: number | null
    disponibilidad: boolean | null
    estado: string | null
    zona_preferencia: string | null
  }

  export type WorkerCountAggregateOutputType = {
    id: number
    name: number
    rut: number
    especialidad: number
    certificaciones: number
    experiencia: number
    disponibilidad: number
    estado: number
    zona_preferencia: number
    _all: number
  }


  export type WorkerAvgAggregateInputType = {
    experiencia?: true
  }

  export type WorkerSumAggregateInputType = {
    experiencia?: true
  }

  export type WorkerMinAggregateInputType = {
    id?: true
    name?: true
    rut?: true
    especialidad?: true
    certificaciones?: true
    experiencia?: true
    disponibilidad?: true
    estado?: true
    zona_preferencia?: true
  }

  export type WorkerMaxAggregateInputType = {
    id?: true
    name?: true
    rut?: true
    especialidad?: true
    certificaciones?: true
    experiencia?: true
    disponibilidad?: true
    estado?: true
    zona_preferencia?: true
  }

  export type WorkerCountAggregateInputType = {
    id?: true
    name?: true
    rut?: true
    especialidad?: true
    certificaciones?: true
    experiencia?: true
    disponibilidad?: true
    estado?: true
    zona_preferencia?: true
    _all?: true
  }

  export type WorkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Worker to aggregate.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workers
    **/
    _count?: true | WorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerMaxAggregateInputType
  }

  export type GetWorkerAggregateType<T extends WorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorker[P]>
      : GetScalarType<T[P], AggregateWorker[P]>
  }




  export type WorkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithAggregationInput | WorkerOrderByWithAggregationInput[]
    by: WorkerScalarFieldEnum[] | WorkerScalarFieldEnum
    having?: WorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerCountAggregateInputType | true
    _avg?: WorkerAvgAggregateInputType
    _sum?: WorkerSumAggregateInputType
    _min?: WorkerMinAggregateInputType
    _max?: WorkerMaxAggregateInputType
  }

  export type WorkerGroupByOutputType = {
    id: string
    name: string
    rut: string | null
    especialidad: string
    certificaciones: string | null
    experiencia: number | null
    disponibilidad: boolean
    estado: string
    zona_preferencia: string | null
    _count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  type GetWorkerGroupByPayload<T extends WorkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerGroupByOutputType[P]>
        }
      >
    >


  export type WorkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rut?: boolean
    especialidad?: boolean
    certificaciones?: boolean
    experiencia?: boolean
    disponibilidad?: boolean
    estado?: boolean
    zona_preferencia?: boolean
    crewWorkers?: boolean | Worker$crewWorkersArgs<ExtArgs>
    certificates?: boolean | Worker$certificatesArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rut?: boolean
    especialidad?: boolean
    certificaciones?: boolean
    experiencia?: boolean
    disponibilidad?: boolean
    estado?: boolean
    zona_preferencia?: boolean
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectScalar = {
    id?: boolean
    name?: boolean
    rut?: boolean
    especialidad?: boolean
    certificaciones?: boolean
    experiencia?: boolean
    disponibilidad?: boolean
    estado?: boolean
    zona_preferencia?: boolean
  }

  export type WorkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crewWorkers?: boolean | Worker$crewWorkersArgs<ExtArgs>
    certificates?: boolean | Worker$certificatesArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Worker"
    objects: {
      crewWorkers: Prisma.$CrewWorkerPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      rut: string | null
      especialidad: string
      certificaciones: string | null
      experiencia: number | null
      disponibilidad: boolean
      estado: string
      zona_preferencia: string | null
    }, ExtArgs["result"]["worker"]>
    composites: {}
  }

  type WorkerGetPayload<S extends boolean | null | undefined | WorkerDefaultArgs> = $Result.GetResult<Prisma.$WorkerPayload, S>

  type WorkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkerCountAggregateInputType | true
    }

  export interface WorkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Worker'], meta: { name: 'Worker' } }
    /**
     * Find zero or one Worker that matches the filter.
     * @param {WorkerFindUniqueArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerFindUniqueArgs>(args: SelectSubset<T, WorkerFindUniqueArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Worker that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkerFindUniqueOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Worker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerFindFirstArgs>(args?: SelectSubset<T, WorkerFindFirstArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Worker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workers
     * const workers = await prisma.worker.findMany()
     * 
     * // Get first 10 Workers
     * const workers = await prisma.worker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerWithIdOnly = await prisma.worker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerFindManyArgs>(args?: SelectSubset<T, WorkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Worker.
     * @param {WorkerCreateArgs} args - Arguments to create a Worker.
     * @example
     * // Create one Worker
     * const Worker = await prisma.worker.create({
     *   data: {
     *     // ... data to create a Worker
     *   }
     * })
     * 
     */
    create<T extends WorkerCreateArgs>(args: SelectSubset<T, WorkerCreateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workers.
     * @param {WorkerCreateManyArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerCreateManyArgs>(args?: SelectSubset<T, WorkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workers and returns the data saved in the database.
     * @param {WorkerCreateManyAndReturnArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workers and only return the `id`
     * const workerWithIdOnly = await prisma.worker.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Worker.
     * @param {WorkerDeleteArgs} args - Arguments to delete one Worker.
     * @example
     * // Delete one Worker
     * const Worker = await prisma.worker.delete({
     *   where: {
     *     // ... filter to delete one Worker
     *   }
     * })
     * 
     */
    delete<T extends WorkerDeleteArgs>(args: SelectSubset<T, WorkerDeleteArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Worker.
     * @param {WorkerUpdateArgs} args - Arguments to update one Worker.
     * @example
     * // Update one Worker
     * const worker = await prisma.worker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerUpdateArgs>(args: SelectSubset<T, WorkerUpdateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workers.
     * @param {WorkerDeleteManyArgs} args - Arguments to filter Workers to delete.
     * @example
     * // Delete a few Workers
     * const { count } = await prisma.worker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerDeleteManyArgs>(args?: SelectSubset<T, WorkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workers
     * const worker = await prisma.worker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerUpdateManyArgs>(args: SelectSubset<T, WorkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Worker.
     * @param {WorkerUpsertArgs} args - Arguments to update or create a Worker.
     * @example
     * // Update or create a Worker
     * const worker = await prisma.worker.upsert({
     *   create: {
     *     // ... data to create a Worker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Worker we want to update
     *   }
     * })
     */
    upsert<T extends WorkerUpsertArgs>(args: SelectSubset<T, WorkerUpsertArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerCountArgs} args - Arguments to filter Workers to count.
     * @example
     * // Count the number of Workers
     * const count = await prisma.worker.count({
     *   where: {
     *     // ... the filter for the Workers we want to count
     *   }
     * })
    **/
    count<T extends WorkerCountArgs>(
      args?: Subset<T, WorkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerAggregateArgs>(args: Subset<T, WorkerAggregateArgs>): Prisma.PrismaPromise<GetWorkerAggregateType<T>>

    /**
     * Group by Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerGroupByArgs['orderBy'] }
        : { orderBy?: WorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Worker model
   */
  readonly fields: WorkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Worker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crewWorkers<T extends Worker$crewWorkersArgs<ExtArgs> = {}>(args?: Subset<T, Worker$crewWorkersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewWorkerPayload<ExtArgs>, T, "findMany"> | Null>
    certificates<T extends Worker$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Worker$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Worker model
   */ 
  interface WorkerFieldRefs {
    readonly id: FieldRef<"Worker", 'String'>
    readonly name: FieldRef<"Worker", 'String'>
    readonly rut: FieldRef<"Worker", 'String'>
    readonly especialidad: FieldRef<"Worker", 'String'>
    readonly certificaciones: FieldRef<"Worker", 'String'>
    readonly experiencia: FieldRef<"Worker", 'Int'>
    readonly disponibilidad: FieldRef<"Worker", 'Boolean'>
    readonly estado: FieldRef<"Worker", 'String'>
    readonly zona_preferencia: FieldRef<"Worker", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Worker findUnique
   */
  export type WorkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findUniqueOrThrow
   */
  export type WorkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findFirst
   */
  export type WorkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findFirstOrThrow
   */
  export type WorkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findMany
   */
  export type WorkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Workers to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker create
   */
  export type WorkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to create a Worker.
     */
    data: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
  }

  /**
   * Worker createMany
   */
  export type WorkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Worker createManyAndReturn
   */
  export type WorkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Worker update
   */
  export type WorkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to update a Worker.
     */
    data: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
    /**
     * Choose, which Worker to update.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker updateMany
   */
  export type WorkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workers.
     */
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyInput>
    /**
     * Filter which Workers to update
     */
    where?: WorkerWhereInput
  }

  /**
   * Worker upsert
   */
  export type WorkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The filter to search for the Worker to update in case it exists.
     */
    where: WorkerWhereUniqueInput
    /**
     * In case the Worker found by the `where` argument doesn't exist, create a new Worker with this data.
     */
    create: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
    /**
     * In case the Worker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
  }

  /**
   * Worker delete
   */
  export type WorkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter which Worker to delete.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker deleteMany
   */
  export type WorkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workers to delete
     */
    where?: WorkerWhereInput
  }

  /**
   * Worker.crewWorkers
   */
  export type Worker$crewWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerInclude<ExtArgs> | null
    where?: CrewWorkerWhereInput
    orderBy?: CrewWorkerOrderByWithRelationInput | CrewWorkerOrderByWithRelationInput[]
    cursor?: CrewWorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewWorkerScalarFieldEnum | CrewWorkerScalarFieldEnum[]
  }

  /**
   * Worker.certificates
   */
  export type Worker$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Worker without action
   */
  export type WorkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
  }


  /**
   * Model Crew
   */

  export type AggregateCrew = {
    _count: CrewCountAggregateOutputType | null
    _avg: CrewAvgAggregateOutputType | null
    _sum: CrewSumAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  export type CrewAvgAggregateOutputType = {
    cantidad_trabajadores: number | null
  }

  export type CrewSumAggregateOutputType = {
    cantidad_trabajadores: number | null
  }

  export type CrewMinAggregateOutputType = {
    id: string | null
    name: string | null
    projectId: string | null
    fecha_inicio: Date | null
    estado: $Enums.CrewState | null
    zona_trabajo: string | null
    fecha_plazo: Date | null
    cantidad_trabajadores: number | null
  }

  export type CrewMaxAggregateOutputType = {
    id: string | null
    name: string | null
    projectId: string | null
    fecha_inicio: Date | null
    estado: $Enums.CrewState | null
    zona_trabajo: string | null
    fecha_plazo: Date | null
    cantidad_trabajadores: number | null
  }

  export type CrewCountAggregateOutputType = {
    id: number
    name: number
    projectId: number
    fecha_inicio: number
    estado: number
    zona_trabajo: number
    fecha_plazo: number
    cantidad_trabajadores: number
    _all: number
  }


  export type CrewAvgAggregateInputType = {
    cantidad_trabajadores?: true
  }

  export type CrewSumAggregateInputType = {
    cantidad_trabajadores?: true
  }

  export type CrewMinAggregateInputType = {
    id?: true
    name?: true
    projectId?: true
    fecha_inicio?: true
    estado?: true
    zona_trabajo?: true
    fecha_plazo?: true
    cantidad_trabajadores?: true
  }

  export type CrewMaxAggregateInputType = {
    id?: true
    name?: true
    projectId?: true
    fecha_inicio?: true
    estado?: true
    zona_trabajo?: true
    fecha_plazo?: true
    cantidad_trabajadores?: true
  }

  export type CrewCountAggregateInputType = {
    id?: true
    name?: true
    projectId?: true
    fecha_inicio?: true
    estado?: true
    zona_trabajo?: true
    fecha_plazo?: true
    cantidad_trabajadores?: true
    _all?: true
  }

  export type CrewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crew to aggregate.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crews
    **/
    _count?: true | CrewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewMaxAggregateInputType
  }

  export type GetCrewAggregateType<T extends CrewAggregateArgs> = {
        [P in keyof T & keyof AggregateCrew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrew[P]>
      : GetScalarType<T[P], AggregateCrew[P]>
  }




  export type CrewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithAggregationInput | CrewOrderByWithAggregationInput[]
    by: CrewScalarFieldEnum[] | CrewScalarFieldEnum
    having?: CrewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewCountAggregateInputType | true
    _avg?: CrewAvgAggregateInputType
    _sum?: CrewSumAggregateInputType
    _min?: CrewMinAggregateInputType
    _max?: CrewMaxAggregateInputType
  }

  export type CrewGroupByOutputType = {
    id: string
    name: string
    projectId: string | null
    fecha_inicio: Date | null
    estado: $Enums.CrewState
    zona_trabajo: string | null
    fecha_plazo: Date | null
    cantidad_trabajadores: number | null
    _count: CrewCountAggregateOutputType | null
    _avg: CrewAvgAggregateOutputType | null
    _sum: CrewSumAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  type GetCrewGroupByPayload<T extends CrewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewGroupByOutputType[P]>
            : GetScalarType<T[P], CrewGroupByOutputType[P]>
        }
      >
    >


  export type CrewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    projectId?: boolean
    fecha_inicio?: boolean
    estado?: boolean
    zona_trabajo?: boolean
    fecha_plazo?: boolean
    cantidad_trabajadores?: boolean
    project?: boolean | Crew$projectArgs<ExtArgs>
    crewWorkers?: boolean | Crew$crewWorkersArgs<ExtArgs>
    logs?: boolean | Crew$logsArgs<ExtArgs>
    materialRequests?: boolean | Crew$materialRequestsArgs<ExtArgs>
    communicationRequests?: boolean | Crew$communicationRequestsArgs<ExtArgs>
    tasks?: boolean | Crew$tasksArgs<ExtArgs>
    _count?: boolean | CrewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crew"]>

  export type CrewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    projectId?: boolean
    fecha_inicio?: boolean
    estado?: boolean
    zona_trabajo?: boolean
    fecha_plazo?: boolean
    cantidad_trabajadores?: boolean
    project?: boolean | Crew$projectArgs<ExtArgs>
  }, ExtArgs["result"]["crew"]>

  export type CrewSelectScalar = {
    id?: boolean
    name?: boolean
    projectId?: boolean
    fecha_inicio?: boolean
    estado?: boolean
    zona_trabajo?: boolean
    fecha_plazo?: boolean
    cantidad_trabajadores?: boolean
  }

  export type CrewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Crew$projectArgs<ExtArgs>
    crewWorkers?: boolean | Crew$crewWorkersArgs<ExtArgs>
    logs?: boolean | Crew$logsArgs<ExtArgs>
    materialRequests?: boolean | Crew$materialRequestsArgs<ExtArgs>
    communicationRequests?: boolean | Crew$communicationRequestsArgs<ExtArgs>
    tasks?: boolean | Crew$tasksArgs<ExtArgs>
    _count?: boolean | CrewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CrewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Crew$projectArgs<ExtArgs>
  }

  export type $CrewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Crew"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      crewWorkers: Prisma.$CrewWorkerPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      materialRequests: Prisma.$MaterialRequestPayload<ExtArgs>[]
      communicationRequests: Prisma.$CommunicationRequestPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      projectId: string | null
      fecha_inicio: Date | null
      estado: $Enums.CrewState
      zona_trabajo: string | null
      fecha_plazo: Date | null
      cantidad_trabajadores: number | null
    }, ExtArgs["result"]["crew"]>
    composites: {}
  }

  type CrewGetPayload<S extends boolean | null | undefined | CrewDefaultArgs> = $Result.GetResult<Prisma.$CrewPayload, S>

  type CrewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CrewCountAggregateInputType | true
    }

  export interface CrewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Crew'], meta: { name: 'Crew' } }
    /**
     * Find zero or one Crew that matches the filter.
     * @param {CrewFindUniqueArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrewFindUniqueArgs>(args: SelectSubset<T, CrewFindUniqueArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Crew that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CrewFindUniqueOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrewFindUniqueOrThrowArgs>(args: SelectSubset<T, CrewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Crew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrewFindFirstArgs>(args?: SelectSubset<T, CrewFindFirstArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Crew that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrewFindFirstOrThrowArgs>(args?: SelectSubset<T, CrewFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Crews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crews
     * const crews = await prisma.crew.findMany()
     * 
     * // Get first 10 Crews
     * const crews = await prisma.crew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crewWithIdOnly = await prisma.crew.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrewFindManyArgs>(args?: SelectSubset<T, CrewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Crew.
     * @param {CrewCreateArgs} args - Arguments to create a Crew.
     * @example
     * // Create one Crew
     * const Crew = await prisma.crew.create({
     *   data: {
     *     // ... data to create a Crew
     *   }
     * })
     * 
     */
    create<T extends CrewCreateArgs>(args: SelectSubset<T, CrewCreateArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Crews.
     * @param {CrewCreateManyArgs} args - Arguments to create many Crews.
     * @example
     * // Create many Crews
     * const crew = await prisma.crew.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrewCreateManyArgs>(args?: SelectSubset<T, CrewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crews and returns the data saved in the database.
     * @param {CrewCreateManyAndReturnArgs} args - Arguments to create many Crews.
     * @example
     * // Create many Crews
     * const crew = await prisma.crew.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crews and only return the `id`
     * const crewWithIdOnly = await prisma.crew.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrewCreateManyAndReturnArgs>(args?: SelectSubset<T, CrewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Crew.
     * @param {CrewDeleteArgs} args - Arguments to delete one Crew.
     * @example
     * // Delete one Crew
     * const Crew = await prisma.crew.delete({
     *   where: {
     *     // ... filter to delete one Crew
     *   }
     * })
     * 
     */
    delete<T extends CrewDeleteArgs>(args: SelectSubset<T, CrewDeleteArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Crew.
     * @param {CrewUpdateArgs} args - Arguments to update one Crew.
     * @example
     * // Update one Crew
     * const crew = await prisma.crew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrewUpdateArgs>(args: SelectSubset<T, CrewUpdateArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Crews.
     * @param {CrewDeleteManyArgs} args - Arguments to filter Crews to delete.
     * @example
     * // Delete a few Crews
     * const { count } = await prisma.crew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrewDeleteManyArgs>(args?: SelectSubset<T, CrewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crews
     * const crew = await prisma.crew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrewUpdateManyArgs>(args: SelectSubset<T, CrewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Crew.
     * @param {CrewUpsertArgs} args - Arguments to update or create a Crew.
     * @example
     * // Update or create a Crew
     * const crew = await prisma.crew.upsert({
     *   create: {
     *     // ... data to create a Crew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crew we want to update
     *   }
     * })
     */
    upsert<T extends CrewUpsertArgs>(args: SelectSubset<T, CrewUpsertArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewCountArgs} args - Arguments to filter Crews to count.
     * @example
     * // Count the number of Crews
     * const count = await prisma.crew.count({
     *   where: {
     *     // ... the filter for the Crews we want to count
     *   }
     * })
    **/
    count<T extends CrewCountArgs>(
      args?: Subset<T, CrewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewAggregateArgs>(args: Subset<T, CrewAggregateArgs>): Prisma.PrismaPromise<GetCrewAggregateType<T>>

    /**
     * Group by Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewGroupByArgs['orderBy'] }
        : { orderBy?: CrewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Crew model
   */
  readonly fields: CrewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Crew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends Crew$projectArgs<ExtArgs> = {}>(args?: Subset<T, Crew$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    crewWorkers<T extends Crew$crewWorkersArgs<ExtArgs> = {}>(args?: Subset<T, Crew$crewWorkersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewWorkerPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends Crew$logsArgs<ExtArgs> = {}>(args?: Subset<T, Crew$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany"> | Null>
    materialRequests<T extends Crew$materialRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Crew$materialRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findMany"> | Null>
    communicationRequests<T extends Crew$communicationRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Crew$communicationRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationRequestPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Crew$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Crew$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Crew model
   */ 
  interface CrewFieldRefs {
    readonly id: FieldRef<"Crew", 'String'>
    readonly name: FieldRef<"Crew", 'String'>
    readonly projectId: FieldRef<"Crew", 'String'>
    readonly fecha_inicio: FieldRef<"Crew", 'DateTime'>
    readonly estado: FieldRef<"Crew", 'CrewState'>
    readonly zona_trabajo: FieldRef<"Crew", 'String'>
    readonly fecha_plazo: FieldRef<"Crew", 'DateTime'>
    readonly cantidad_trabajadores: FieldRef<"Crew", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Crew findUnique
   */
  export type CrewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where: CrewWhereUniqueInput
  }

  /**
   * Crew findUniqueOrThrow
   */
  export type CrewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where: CrewWhereUniqueInput
  }

  /**
   * Crew findFirst
   */
  export type CrewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crews.
     */
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Crew findFirstOrThrow
   */
  export type CrewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crews.
     */
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Crew findMany
   */
  export type CrewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crews to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Crew create
   */
  export type CrewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The data needed to create a Crew.
     */
    data: XOR<CrewCreateInput, CrewUncheckedCreateInput>
  }

  /**
   * Crew createMany
   */
  export type CrewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Crews.
     */
    data: CrewCreateManyInput | CrewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Crew createManyAndReturn
   */
  export type CrewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Crews.
     */
    data: CrewCreateManyInput | CrewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Crew update
   */
  export type CrewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The data needed to update a Crew.
     */
    data: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
    /**
     * Choose, which Crew to update.
     */
    where: CrewWhereUniqueInput
  }

  /**
   * Crew updateMany
   */
  export type CrewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Crews.
     */
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyInput>
    /**
     * Filter which Crews to update
     */
    where?: CrewWhereInput
  }

  /**
   * Crew upsert
   */
  export type CrewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The filter to search for the Crew to update in case it exists.
     */
    where: CrewWhereUniqueInput
    /**
     * In case the Crew found by the `where` argument doesn't exist, create a new Crew with this data.
     */
    create: XOR<CrewCreateInput, CrewUncheckedCreateInput>
    /**
     * In case the Crew was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
  }

  /**
   * Crew delete
   */
  export type CrewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter which Crew to delete.
     */
    where: CrewWhereUniqueInput
  }

  /**
   * Crew deleteMany
   */
  export type CrewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crews to delete
     */
    where?: CrewWhereInput
  }

  /**
   * Crew.project
   */
  export type Crew$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Crew.crewWorkers
   */
  export type Crew$crewWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerInclude<ExtArgs> | null
    where?: CrewWorkerWhereInput
    orderBy?: CrewWorkerOrderByWithRelationInput | CrewWorkerOrderByWithRelationInput[]
    cursor?: CrewWorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewWorkerScalarFieldEnum | CrewWorkerScalarFieldEnum[]
  }

  /**
   * Crew.logs
   */
  export type Crew$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Crew.materialRequests
   */
  export type Crew$materialRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    where?: MaterialRequestWhereInput
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    cursor?: MaterialRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialRequestScalarFieldEnum | MaterialRequestScalarFieldEnum[]
  }

  /**
   * Crew.communicationRequests
   */
  export type Crew$communicationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestInclude<ExtArgs> | null
    where?: CommunicationRequestWhereInput
    orderBy?: CommunicationRequestOrderByWithRelationInput | CommunicationRequestOrderByWithRelationInput[]
    cursor?: CommunicationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationRequestScalarFieldEnum | CommunicationRequestScalarFieldEnum[]
  }

  /**
   * Crew.tasks
   */
  export type Crew$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Crew without action
   */
  export type CrewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
  }


  /**
   * Model CrewWorker
   */

  export type AggregateCrewWorker = {
    _count: CrewWorkerCountAggregateOutputType | null
    _min: CrewWorkerMinAggregateOutputType | null
    _max: CrewWorkerMaxAggregateOutputType | null
  }

  export type CrewWorkerMinAggregateOutputType = {
    id: string | null
    crewId: string | null
    workerId: string | null
    role: string | null
    fecha_asignacion: Date | null
  }

  export type CrewWorkerMaxAggregateOutputType = {
    id: string | null
    crewId: string | null
    workerId: string | null
    role: string | null
    fecha_asignacion: Date | null
  }

  export type CrewWorkerCountAggregateOutputType = {
    id: number
    crewId: number
    workerId: number
    role: number
    fecha_asignacion: number
    _all: number
  }


  export type CrewWorkerMinAggregateInputType = {
    id?: true
    crewId?: true
    workerId?: true
    role?: true
    fecha_asignacion?: true
  }

  export type CrewWorkerMaxAggregateInputType = {
    id?: true
    crewId?: true
    workerId?: true
    role?: true
    fecha_asignacion?: true
  }

  export type CrewWorkerCountAggregateInputType = {
    id?: true
    crewId?: true
    workerId?: true
    role?: true
    fecha_asignacion?: true
    _all?: true
  }

  export type CrewWorkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewWorker to aggregate.
     */
    where?: CrewWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewWorkers to fetch.
     */
    orderBy?: CrewWorkerOrderByWithRelationInput | CrewWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewWorkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrewWorkers
    **/
    _count?: true | CrewWorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewWorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewWorkerMaxAggregateInputType
  }

  export type GetCrewWorkerAggregateType<T extends CrewWorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateCrewWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrewWorker[P]>
      : GetScalarType<T[P], AggregateCrewWorker[P]>
  }




  export type CrewWorkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWorkerWhereInput
    orderBy?: CrewWorkerOrderByWithAggregationInput | CrewWorkerOrderByWithAggregationInput[]
    by: CrewWorkerScalarFieldEnum[] | CrewWorkerScalarFieldEnum
    having?: CrewWorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewWorkerCountAggregateInputType | true
    _min?: CrewWorkerMinAggregateInputType
    _max?: CrewWorkerMaxAggregateInputType
  }

  export type CrewWorkerGroupByOutputType = {
    id: string
    crewId: string
    workerId: string
    role: string
    fecha_asignacion: Date
    _count: CrewWorkerCountAggregateOutputType | null
    _min: CrewWorkerMinAggregateOutputType | null
    _max: CrewWorkerMaxAggregateOutputType | null
  }

  type GetCrewWorkerGroupByPayload<T extends CrewWorkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewWorkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewWorkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewWorkerGroupByOutputType[P]>
            : GetScalarType<T[P], CrewWorkerGroupByOutputType[P]>
        }
      >
    >


  export type CrewWorkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    crewId?: boolean
    workerId?: boolean
    role?: boolean
    fecha_asignacion?: boolean
    crew?: boolean | CrewDefaultArgs<ExtArgs>
    worker?: boolean | WorkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crewWorker"]>

  export type CrewWorkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    crewId?: boolean
    workerId?: boolean
    role?: boolean
    fecha_asignacion?: boolean
    crew?: boolean | CrewDefaultArgs<ExtArgs>
    worker?: boolean | WorkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crewWorker"]>

  export type CrewWorkerSelectScalar = {
    id?: boolean
    crewId?: boolean
    workerId?: boolean
    role?: boolean
    fecha_asignacion?: boolean
  }

  export type CrewWorkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crew?: boolean | CrewDefaultArgs<ExtArgs>
    worker?: boolean | WorkerDefaultArgs<ExtArgs>
  }
  export type CrewWorkerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crew?: boolean | CrewDefaultArgs<ExtArgs>
    worker?: boolean | WorkerDefaultArgs<ExtArgs>
  }

  export type $CrewWorkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrewWorker"
    objects: {
      crew: Prisma.$CrewPayload<ExtArgs>
      worker: Prisma.$WorkerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      crewId: string
      workerId: string
      role: string
      fecha_asignacion: Date
    }, ExtArgs["result"]["crewWorker"]>
    composites: {}
  }

  type CrewWorkerGetPayload<S extends boolean | null | undefined | CrewWorkerDefaultArgs> = $Result.GetResult<Prisma.$CrewWorkerPayload, S>

  type CrewWorkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrewWorkerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CrewWorkerCountAggregateInputType | true
    }

  export interface CrewWorkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrewWorker'], meta: { name: 'CrewWorker' } }
    /**
     * Find zero or one CrewWorker that matches the filter.
     * @param {CrewWorkerFindUniqueArgs} args - Arguments to find a CrewWorker
     * @example
     * // Get one CrewWorker
     * const crewWorker = await prisma.crewWorker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrewWorkerFindUniqueArgs>(args: SelectSubset<T, CrewWorkerFindUniqueArgs<ExtArgs>>): Prisma__CrewWorkerClient<$Result.GetResult<Prisma.$CrewWorkerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CrewWorker that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CrewWorkerFindUniqueOrThrowArgs} args - Arguments to find a CrewWorker
     * @example
     * // Get one CrewWorker
     * const crewWorker = await prisma.crewWorker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrewWorkerFindUniqueOrThrowArgs>(args: SelectSubset<T, CrewWorkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrewWorkerClient<$Result.GetResult<Prisma.$CrewWorkerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CrewWorker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewWorkerFindFirstArgs} args - Arguments to find a CrewWorker
     * @example
     * // Get one CrewWorker
     * const crewWorker = await prisma.crewWorker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrewWorkerFindFirstArgs>(args?: SelectSubset<T, CrewWorkerFindFirstArgs<ExtArgs>>): Prisma__CrewWorkerClient<$Result.GetResult<Prisma.$CrewWorkerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CrewWorker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewWorkerFindFirstOrThrowArgs} args - Arguments to find a CrewWorker
     * @example
     * // Get one CrewWorker
     * const crewWorker = await prisma.crewWorker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrewWorkerFindFirstOrThrowArgs>(args?: SelectSubset<T, CrewWorkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrewWorkerClient<$Result.GetResult<Prisma.$CrewWorkerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CrewWorkers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewWorkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrewWorkers
     * const crewWorkers = await prisma.crewWorker.findMany()
     * 
     * // Get first 10 CrewWorkers
     * const crewWorkers = await prisma.crewWorker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crewWorkerWithIdOnly = await prisma.crewWorker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrewWorkerFindManyArgs>(args?: SelectSubset<T, CrewWorkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewWorkerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CrewWorker.
     * @param {CrewWorkerCreateArgs} args - Arguments to create a CrewWorker.
     * @example
     * // Create one CrewWorker
     * const CrewWorker = await prisma.crewWorker.create({
     *   data: {
     *     // ... data to create a CrewWorker
     *   }
     * })
     * 
     */
    create<T extends CrewWorkerCreateArgs>(args: SelectSubset<T, CrewWorkerCreateArgs<ExtArgs>>): Prisma__CrewWorkerClient<$Result.GetResult<Prisma.$CrewWorkerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CrewWorkers.
     * @param {CrewWorkerCreateManyArgs} args - Arguments to create many CrewWorkers.
     * @example
     * // Create many CrewWorkers
     * const crewWorker = await prisma.crewWorker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrewWorkerCreateManyArgs>(args?: SelectSubset<T, CrewWorkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrewWorkers and returns the data saved in the database.
     * @param {CrewWorkerCreateManyAndReturnArgs} args - Arguments to create many CrewWorkers.
     * @example
     * // Create many CrewWorkers
     * const crewWorker = await prisma.crewWorker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrewWorkers and only return the `id`
     * const crewWorkerWithIdOnly = await prisma.crewWorker.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrewWorkerCreateManyAndReturnArgs>(args?: SelectSubset<T, CrewWorkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewWorkerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CrewWorker.
     * @param {CrewWorkerDeleteArgs} args - Arguments to delete one CrewWorker.
     * @example
     * // Delete one CrewWorker
     * const CrewWorker = await prisma.crewWorker.delete({
     *   where: {
     *     // ... filter to delete one CrewWorker
     *   }
     * })
     * 
     */
    delete<T extends CrewWorkerDeleteArgs>(args: SelectSubset<T, CrewWorkerDeleteArgs<ExtArgs>>): Prisma__CrewWorkerClient<$Result.GetResult<Prisma.$CrewWorkerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CrewWorker.
     * @param {CrewWorkerUpdateArgs} args - Arguments to update one CrewWorker.
     * @example
     * // Update one CrewWorker
     * const crewWorker = await prisma.crewWorker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrewWorkerUpdateArgs>(args: SelectSubset<T, CrewWorkerUpdateArgs<ExtArgs>>): Prisma__CrewWorkerClient<$Result.GetResult<Prisma.$CrewWorkerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CrewWorkers.
     * @param {CrewWorkerDeleteManyArgs} args - Arguments to filter CrewWorkers to delete.
     * @example
     * // Delete a few CrewWorkers
     * const { count } = await prisma.crewWorker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrewWorkerDeleteManyArgs>(args?: SelectSubset<T, CrewWorkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrewWorkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewWorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrewWorkers
     * const crewWorker = await prisma.crewWorker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrewWorkerUpdateManyArgs>(args: SelectSubset<T, CrewWorkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrewWorker.
     * @param {CrewWorkerUpsertArgs} args - Arguments to update or create a CrewWorker.
     * @example
     * // Update or create a CrewWorker
     * const crewWorker = await prisma.crewWorker.upsert({
     *   create: {
     *     // ... data to create a CrewWorker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrewWorker we want to update
     *   }
     * })
     */
    upsert<T extends CrewWorkerUpsertArgs>(args: SelectSubset<T, CrewWorkerUpsertArgs<ExtArgs>>): Prisma__CrewWorkerClient<$Result.GetResult<Prisma.$CrewWorkerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CrewWorkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewWorkerCountArgs} args - Arguments to filter CrewWorkers to count.
     * @example
     * // Count the number of CrewWorkers
     * const count = await prisma.crewWorker.count({
     *   where: {
     *     // ... the filter for the CrewWorkers we want to count
     *   }
     * })
    **/
    count<T extends CrewWorkerCountArgs>(
      args?: Subset<T, CrewWorkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewWorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrewWorker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewWorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewWorkerAggregateArgs>(args: Subset<T, CrewWorkerAggregateArgs>): Prisma.PrismaPromise<GetCrewWorkerAggregateType<T>>

    /**
     * Group by CrewWorker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewWorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewWorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewWorkerGroupByArgs['orderBy'] }
        : { orderBy?: CrewWorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewWorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewWorkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrewWorker model
   */
  readonly fields: CrewWorkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrewWorker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewWorkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crew<T extends CrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewDefaultArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    worker<T extends WorkerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkerDefaultArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrewWorker model
   */ 
  interface CrewWorkerFieldRefs {
    readonly id: FieldRef<"CrewWorker", 'String'>
    readonly crewId: FieldRef<"CrewWorker", 'String'>
    readonly workerId: FieldRef<"CrewWorker", 'String'>
    readonly role: FieldRef<"CrewWorker", 'String'>
    readonly fecha_asignacion: FieldRef<"CrewWorker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrewWorker findUnique
   */
  export type CrewWorkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerInclude<ExtArgs> | null
    /**
     * Filter, which CrewWorker to fetch.
     */
    where: CrewWorkerWhereUniqueInput
  }

  /**
   * CrewWorker findUniqueOrThrow
   */
  export type CrewWorkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerInclude<ExtArgs> | null
    /**
     * Filter, which CrewWorker to fetch.
     */
    where: CrewWorkerWhereUniqueInput
  }

  /**
   * CrewWorker findFirst
   */
  export type CrewWorkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerInclude<ExtArgs> | null
    /**
     * Filter, which CrewWorker to fetch.
     */
    where?: CrewWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewWorkers to fetch.
     */
    orderBy?: CrewWorkerOrderByWithRelationInput | CrewWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewWorkers.
     */
    cursor?: CrewWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewWorkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewWorkers.
     */
    distinct?: CrewWorkerScalarFieldEnum | CrewWorkerScalarFieldEnum[]
  }

  /**
   * CrewWorker findFirstOrThrow
   */
  export type CrewWorkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerInclude<ExtArgs> | null
    /**
     * Filter, which CrewWorker to fetch.
     */
    where?: CrewWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewWorkers to fetch.
     */
    orderBy?: CrewWorkerOrderByWithRelationInput | CrewWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewWorkers.
     */
    cursor?: CrewWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewWorkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewWorkers.
     */
    distinct?: CrewWorkerScalarFieldEnum | CrewWorkerScalarFieldEnum[]
  }

  /**
   * CrewWorker findMany
   */
  export type CrewWorkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerInclude<ExtArgs> | null
    /**
     * Filter, which CrewWorkers to fetch.
     */
    where?: CrewWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewWorkers to fetch.
     */
    orderBy?: CrewWorkerOrderByWithRelationInput | CrewWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrewWorkers.
     */
    cursor?: CrewWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewWorkers.
     */
    skip?: number
    distinct?: CrewWorkerScalarFieldEnum | CrewWorkerScalarFieldEnum[]
  }

  /**
   * CrewWorker create
   */
  export type CrewWorkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerInclude<ExtArgs> | null
    /**
     * The data needed to create a CrewWorker.
     */
    data: XOR<CrewWorkerCreateInput, CrewWorkerUncheckedCreateInput>
  }

  /**
   * CrewWorker createMany
   */
  export type CrewWorkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrewWorkers.
     */
    data: CrewWorkerCreateManyInput | CrewWorkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrewWorker createManyAndReturn
   */
  export type CrewWorkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CrewWorkers.
     */
    data: CrewWorkerCreateManyInput | CrewWorkerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrewWorker update
   */
  export type CrewWorkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerInclude<ExtArgs> | null
    /**
     * The data needed to update a CrewWorker.
     */
    data: XOR<CrewWorkerUpdateInput, CrewWorkerUncheckedUpdateInput>
    /**
     * Choose, which CrewWorker to update.
     */
    where: CrewWorkerWhereUniqueInput
  }

  /**
   * CrewWorker updateMany
   */
  export type CrewWorkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrewWorkers.
     */
    data: XOR<CrewWorkerUpdateManyMutationInput, CrewWorkerUncheckedUpdateManyInput>
    /**
     * Filter which CrewWorkers to update
     */
    where?: CrewWorkerWhereInput
  }

  /**
   * CrewWorker upsert
   */
  export type CrewWorkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerInclude<ExtArgs> | null
    /**
     * The filter to search for the CrewWorker to update in case it exists.
     */
    where: CrewWorkerWhereUniqueInput
    /**
     * In case the CrewWorker found by the `where` argument doesn't exist, create a new CrewWorker with this data.
     */
    create: XOR<CrewWorkerCreateInput, CrewWorkerUncheckedCreateInput>
    /**
     * In case the CrewWorker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewWorkerUpdateInput, CrewWorkerUncheckedUpdateInput>
  }

  /**
   * CrewWorker delete
   */
  export type CrewWorkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerInclude<ExtArgs> | null
    /**
     * Filter which CrewWorker to delete.
     */
    where: CrewWorkerWhereUniqueInput
  }

  /**
   * CrewWorker deleteMany
   */
  export type CrewWorkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewWorkers to delete
     */
    where?: CrewWorkerWhereInput
  }

  /**
   * CrewWorker without action
   */
  export type CrewWorkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewWorker
     */
    select?: CrewWorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewWorkerInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogMinAggregateOutputType = {
    id: string | null
    crewId: string | null
    projectId: string | null
    descripcion: string | null
    incidentes: string | null
    consumo_materiales: string | null
    avance: string | null
    fecha: Date | null
    responsableId: string | null
    actividades: string | null
    materiales_consumidos: string | null
    tiempos_trabajo: string | null
    observaciones: string | null
    estado_herramientas: string | null
  }

  export type LogMaxAggregateOutputType = {
    id: string | null
    crewId: string | null
    projectId: string | null
    descripcion: string | null
    incidentes: string | null
    consumo_materiales: string | null
    avance: string | null
    fecha: Date | null
    responsableId: string | null
    actividades: string | null
    materiales_consumidos: string | null
    tiempos_trabajo: string | null
    observaciones: string | null
    estado_herramientas: string | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    crewId: number
    projectId: number
    descripcion: number
    incidentes: number
    consumo_materiales: number
    avance: number
    fecha: number
    responsableId: number
    actividades: number
    materiales_consumidos: number
    tiempos_trabajo: number
    observaciones: number
    estado_herramientas: number
    _all: number
  }


  export type LogMinAggregateInputType = {
    id?: true
    crewId?: true
    projectId?: true
    descripcion?: true
    incidentes?: true
    consumo_materiales?: true
    avance?: true
    fecha?: true
    responsableId?: true
    actividades?: true
    materiales_consumidos?: true
    tiempos_trabajo?: true
    observaciones?: true
    estado_herramientas?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    crewId?: true
    projectId?: true
    descripcion?: true
    incidentes?: true
    consumo_materiales?: true
    avance?: true
    fecha?: true
    responsableId?: true
    actividades?: true
    materiales_consumidos?: true
    tiempos_trabajo?: true
    observaciones?: true
    estado_herramientas?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    crewId?: true
    projectId?: true
    descripcion?: true
    incidentes?: true
    consumo_materiales?: true
    avance?: true
    fecha?: true
    responsableId?: true
    actividades?: true
    materiales_consumidos?: true
    tiempos_trabajo?: true
    observaciones?: true
    estado_herramientas?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: string
    crewId: string
    projectId: string
    descripcion: string | null
    incidentes: string | null
    consumo_materiales: string | null
    avance: string | null
    fecha: Date
    responsableId: string
    actividades: string | null
    materiales_consumidos: string | null
    tiempos_trabajo: string | null
    observaciones: string | null
    estado_herramientas: string | null
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    crewId?: boolean
    projectId?: boolean
    descripcion?: boolean
    incidentes?: boolean
    consumo_materiales?: boolean
    avance?: boolean
    fecha?: boolean
    responsableId?: boolean
    actividades?: boolean
    materiales_consumidos?: boolean
    tiempos_trabajo?: boolean
    observaciones?: boolean
    estado_herramientas?: boolean
    crew?: boolean | CrewDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    responsable?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    crewId?: boolean
    projectId?: boolean
    descripcion?: boolean
    incidentes?: boolean
    consumo_materiales?: boolean
    avance?: boolean
    fecha?: boolean
    responsableId?: boolean
    actividades?: boolean
    materiales_consumidos?: boolean
    tiempos_trabajo?: boolean
    observaciones?: boolean
    estado_herramientas?: boolean
    crew?: boolean | CrewDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    responsable?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    crewId?: boolean
    projectId?: boolean
    descripcion?: boolean
    incidentes?: boolean
    consumo_materiales?: boolean
    avance?: boolean
    fecha?: boolean
    responsableId?: boolean
    actividades?: boolean
    materiales_consumidos?: boolean
    tiempos_trabajo?: boolean
    observaciones?: boolean
    estado_herramientas?: boolean
  }

  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crew?: boolean | CrewDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    responsable?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crew?: boolean | CrewDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    responsable?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      crew: Prisma.$CrewPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
      responsable: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      crewId: string
      projectId: string
      descripcion: string | null
      incidentes: string | null
      consumo_materiales: string | null
      avance: string | null
      fecha: Date
      responsableId: string
      actividades: string | null
      materiales_consumidos: string | null
      tiempos_trabajo: string | null
      observaciones: string | null
      estado_herramientas: string | null
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogCreateManyAndReturnArgs>(args?: SelectSubset<T, LogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crew<T extends CrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewDefaultArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responsable<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */ 
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'String'>
    readonly crewId: FieldRef<"Log", 'String'>
    readonly projectId: FieldRef<"Log", 'String'>
    readonly descripcion: FieldRef<"Log", 'String'>
    readonly incidentes: FieldRef<"Log", 'String'>
    readonly consumo_materiales: FieldRef<"Log", 'String'>
    readonly avance: FieldRef<"Log", 'String'>
    readonly fecha: FieldRef<"Log", 'DateTime'>
    readonly responsableId: FieldRef<"Log", 'String'>
    readonly actividades: FieldRef<"Log", 'String'>
    readonly materiales_consumidos: FieldRef<"Log", 'String'>
    readonly tiempos_trabajo: FieldRef<"Log", 'String'>
    readonly observaciones: FieldRef<"Log", 'String'>
    readonly estado_herramientas: FieldRef<"Log", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log createManyAndReturn
   */
  export type LogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    stock: number | null
    precio: number | null
  }

  export type MaterialSumAggregateOutputType = {
    stock: number | null
    precio: number | null
  }

  export type MaterialMinAggregateOutputType = {
    id: string | null
    name: string | null
    descripcion: string | null
    stock: number | null
    unidad: string | null
    precio: number | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    descripcion: string | null
    stock: number | null
    unidad: string | null
    precio: number | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    name: number
    descripcion: number
    stock: number
    unidad: number
    precio: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    stock?: true
    precio?: true
  }

  export type MaterialSumAggregateInputType = {
    stock?: true
    precio?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    name?: true
    descripcion?: true
    stock?: true
    unidad?: true
    precio?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    name?: true
    descripcion?: true
    stock?: true
    unidad?: true
    precio?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    name?: true
    descripcion?: true
    stock?: true
    unidad?: true
    precio?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: string
    name: string
    descripcion: string | null
    stock: number
    unidad: string
    precio: number
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    descripcion?: boolean
    stock?: boolean
    unidad?: boolean
    precio?: boolean
    requests?: boolean | Material$requestsArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    descripcion?: boolean
    stock?: boolean
    unidad?: boolean
    precio?: boolean
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    name?: boolean
    descripcion?: boolean
    stock?: boolean
    unidad?: boolean
    precio?: boolean
  }

  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requests?: boolean | Material$requestsArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      requests: Prisma.$MaterialRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      descripcion: string | null
      stock: number
      unidad: string
      precio: number
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requests<T extends Material$requestsArgs<ExtArgs> = {}>(args?: Subset<T, Material$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */ 
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'String'>
    readonly name: FieldRef<"Material", 'String'>
    readonly descripcion: FieldRef<"Material", 'String'>
    readonly stock: FieldRef<"Material", 'Int'>
    readonly unidad: FieldRef<"Material", 'String'>
    readonly precio: FieldRef<"Material", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
  }

  /**
   * Material.requests
   */
  export type Material$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    where?: MaterialRequestWhereInput
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    cursor?: MaterialRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialRequestScalarFieldEnum | MaterialRequestScalarFieldEnum[]
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model MaterialRequest
   */

  export type AggregateMaterialRequest = {
    _count: MaterialRequestCountAggregateOutputType | null
    _avg: MaterialRequestAvgAggregateOutputType | null
    _sum: MaterialRequestSumAggregateOutputType | null
    _min: MaterialRequestMinAggregateOutputType | null
    _max: MaterialRequestMaxAggregateOutputType | null
  }

  export type MaterialRequestAvgAggregateOutputType = {
    cantidad: number | null
  }

  export type MaterialRequestSumAggregateOutputType = {
    cantidad: number | null
  }

  export type MaterialRequestMinAggregateOutputType = {
    id: string | null
    materialId: string | null
    projectId: string | null
    crewId: string | null
    cantidad: number | null
    estado: $Enums.MaterialRequestState | null
    createdAt: Date | null
  }

  export type MaterialRequestMaxAggregateOutputType = {
    id: string | null
    materialId: string | null
    projectId: string | null
    crewId: string | null
    cantidad: number | null
    estado: $Enums.MaterialRequestState | null
    createdAt: Date | null
  }

  export type MaterialRequestCountAggregateOutputType = {
    id: number
    materialId: number
    projectId: number
    crewId: number
    cantidad: number
    estado: number
    createdAt: number
    _all: number
  }


  export type MaterialRequestAvgAggregateInputType = {
    cantidad?: true
  }

  export type MaterialRequestSumAggregateInputType = {
    cantidad?: true
  }

  export type MaterialRequestMinAggregateInputType = {
    id?: true
    materialId?: true
    projectId?: true
    crewId?: true
    cantidad?: true
    estado?: true
    createdAt?: true
  }

  export type MaterialRequestMaxAggregateInputType = {
    id?: true
    materialId?: true
    projectId?: true
    crewId?: true
    cantidad?: true
    estado?: true
    createdAt?: true
  }

  export type MaterialRequestCountAggregateInputType = {
    id?: true
    materialId?: true
    projectId?: true
    crewId?: true
    cantidad?: true
    estado?: true
    createdAt?: true
    _all?: true
  }

  export type MaterialRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialRequest to aggregate.
     */
    where?: MaterialRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequests to fetch.
     */
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialRequests
    **/
    _count?: true | MaterialRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialRequestMaxAggregateInputType
  }

  export type GetMaterialRequestAggregateType<T extends MaterialRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialRequest[P]>
      : GetScalarType<T[P], AggregateMaterialRequest[P]>
  }




  export type MaterialRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialRequestWhereInput
    orderBy?: MaterialRequestOrderByWithAggregationInput | MaterialRequestOrderByWithAggregationInput[]
    by: MaterialRequestScalarFieldEnum[] | MaterialRequestScalarFieldEnum
    having?: MaterialRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialRequestCountAggregateInputType | true
    _avg?: MaterialRequestAvgAggregateInputType
    _sum?: MaterialRequestSumAggregateInputType
    _min?: MaterialRequestMinAggregateInputType
    _max?: MaterialRequestMaxAggregateInputType
  }

  export type MaterialRequestGroupByOutputType = {
    id: string
    materialId: string
    projectId: string
    crewId: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt: Date
    _count: MaterialRequestCountAggregateOutputType | null
    _avg: MaterialRequestAvgAggregateOutputType | null
    _sum: MaterialRequestSumAggregateOutputType | null
    _min: MaterialRequestMinAggregateOutputType | null
    _max: MaterialRequestMaxAggregateOutputType | null
  }

  type GetMaterialRequestGroupByPayload<T extends MaterialRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialRequestGroupByOutputType[P]>
        }
      >
    >


  export type MaterialRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    projectId?: boolean
    crewId?: boolean
    cantidad?: boolean
    estado?: boolean
    createdAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialRequest"]>

  export type MaterialRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    projectId?: boolean
    crewId?: boolean
    cantidad?: boolean
    estado?: boolean
    createdAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialRequest"]>

  export type MaterialRequestSelectScalar = {
    id?: boolean
    materialId?: boolean
    projectId?: boolean
    crewId?: boolean
    cantidad?: boolean
    estado?: boolean
    createdAt?: boolean
  }

  export type MaterialRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }
  export type MaterialRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }

  export type $MaterialRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialRequest"
    objects: {
      material: Prisma.$MaterialPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
      crew: Prisma.$CrewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      materialId: string
      projectId: string
      crewId: string
      cantidad: number
      estado: $Enums.MaterialRequestState
      createdAt: Date
    }, ExtArgs["result"]["materialRequest"]>
    composites: {}
  }

  type MaterialRequestGetPayload<S extends boolean | null | undefined | MaterialRequestDefaultArgs> = $Result.GetResult<Prisma.$MaterialRequestPayload, S>

  type MaterialRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialRequestCountAggregateInputType | true
    }

  export interface MaterialRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialRequest'], meta: { name: 'MaterialRequest' } }
    /**
     * Find zero or one MaterialRequest that matches the filter.
     * @param {MaterialRequestFindUniqueArgs} args - Arguments to find a MaterialRequest
     * @example
     * // Get one MaterialRequest
     * const materialRequest = await prisma.materialRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialRequestFindUniqueArgs>(args: SelectSubset<T, MaterialRequestFindUniqueArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaterialRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialRequestFindUniqueOrThrowArgs} args - Arguments to find a MaterialRequest
     * @example
     * // Get one MaterialRequest
     * const materialRequest = await prisma.materialRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaterialRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestFindFirstArgs} args - Arguments to find a MaterialRequest
     * @example
     * // Get one MaterialRequest
     * const materialRequest = await prisma.materialRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialRequestFindFirstArgs>(args?: SelectSubset<T, MaterialRequestFindFirstArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaterialRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestFindFirstOrThrowArgs} args - Arguments to find a MaterialRequest
     * @example
     * // Get one MaterialRequest
     * const materialRequest = await prisma.materialRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaterialRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialRequests
     * const materialRequests = await prisma.materialRequest.findMany()
     * 
     * // Get first 10 MaterialRequests
     * const materialRequests = await prisma.materialRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialRequestWithIdOnly = await prisma.materialRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialRequestFindManyArgs>(args?: SelectSubset<T, MaterialRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaterialRequest.
     * @param {MaterialRequestCreateArgs} args - Arguments to create a MaterialRequest.
     * @example
     * // Create one MaterialRequest
     * const MaterialRequest = await prisma.materialRequest.create({
     *   data: {
     *     // ... data to create a MaterialRequest
     *   }
     * })
     * 
     */
    create<T extends MaterialRequestCreateArgs>(args: SelectSubset<T, MaterialRequestCreateArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaterialRequests.
     * @param {MaterialRequestCreateManyArgs} args - Arguments to create many MaterialRequests.
     * @example
     * // Create many MaterialRequests
     * const materialRequest = await prisma.materialRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialRequestCreateManyArgs>(args?: SelectSubset<T, MaterialRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaterialRequests and returns the data saved in the database.
     * @param {MaterialRequestCreateManyAndReturnArgs} args - Arguments to create many MaterialRequests.
     * @example
     * // Create many MaterialRequests
     * const materialRequest = await prisma.materialRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaterialRequests and only return the `id`
     * const materialRequestWithIdOnly = await prisma.materialRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MaterialRequest.
     * @param {MaterialRequestDeleteArgs} args - Arguments to delete one MaterialRequest.
     * @example
     * // Delete one MaterialRequest
     * const MaterialRequest = await prisma.materialRequest.delete({
     *   where: {
     *     // ... filter to delete one MaterialRequest
     *   }
     * })
     * 
     */
    delete<T extends MaterialRequestDeleteArgs>(args: SelectSubset<T, MaterialRequestDeleteArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaterialRequest.
     * @param {MaterialRequestUpdateArgs} args - Arguments to update one MaterialRequest.
     * @example
     * // Update one MaterialRequest
     * const materialRequest = await prisma.materialRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialRequestUpdateArgs>(args: SelectSubset<T, MaterialRequestUpdateArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaterialRequests.
     * @param {MaterialRequestDeleteManyArgs} args - Arguments to filter MaterialRequests to delete.
     * @example
     * // Delete a few MaterialRequests
     * const { count } = await prisma.materialRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialRequestDeleteManyArgs>(args?: SelectSubset<T, MaterialRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialRequests
     * const materialRequest = await prisma.materialRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialRequestUpdateManyArgs>(args: SelectSubset<T, MaterialRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialRequest.
     * @param {MaterialRequestUpsertArgs} args - Arguments to update or create a MaterialRequest.
     * @example
     * // Update or create a MaterialRequest
     * const materialRequest = await prisma.materialRequest.upsert({
     *   create: {
     *     // ... data to create a MaterialRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialRequest we want to update
     *   }
     * })
     */
    upsert<T extends MaterialRequestUpsertArgs>(args: SelectSubset<T, MaterialRequestUpsertArgs<ExtArgs>>): Prisma__MaterialRequestClient<$Result.GetResult<Prisma.$MaterialRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaterialRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestCountArgs} args - Arguments to filter MaterialRequests to count.
     * @example
     * // Count the number of MaterialRequests
     * const count = await prisma.materialRequest.count({
     *   where: {
     *     // ... the filter for the MaterialRequests we want to count
     *   }
     * })
    **/
    count<T extends MaterialRequestCountArgs>(
      args?: Subset<T, MaterialRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialRequestAggregateArgs>(args: Subset<T, MaterialRequestAggregateArgs>): Prisma.PrismaPromise<GetMaterialRequestAggregateType<T>>

    /**
     * Group by MaterialRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialRequestGroupByArgs['orderBy'] }
        : { orderBy?: MaterialRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialRequest model
   */
  readonly fields: MaterialRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    crew<T extends CrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewDefaultArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialRequest model
   */ 
  interface MaterialRequestFieldRefs {
    readonly id: FieldRef<"MaterialRequest", 'String'>
    readonly materialId: FieldRef<"MaterialRequest", 'String'>
    readonly projectId: FieldRef<"MaterialRequest", 'String'>
    readonly crewId: FieldRef<"MaterialRequest", 'String'>
    readonly cantidad: FieldRef<"MaterialRequest", 'Int'>
    readonly estado: FieldRef<"MaterialRequest", 'MaterialRequestState'>
    readonly createdAt: FieldRef<"MaterialRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaterialRequest findUnique
   */
  export type MaterialRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequest to fetch.
     */
    where: MaterialRequestWhereUniqueInput
  }

  /**
   * MaterialRequest findUniqueOrThrow
   */
  export type MaterialRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequest to fetch.
     */
    where: MaterialRequestWhereUniqueInput
  }

  /**
   * MaterialRequest findFirst
   */
  export type MaterialRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequest to fetch.
     */
    where?: MaterialRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequests to fetch.
     */
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialRequests.
     */
    cursor?: MaterialRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialRequests.
     */
    distinct?: MaterialRequestScalarFieldEnum | MaterialRequestScalarFieldEnum[]
  }

  /**
   * MaterialRequest findFirstOrThrow
   */
  export type MaterialRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequest to fetch.
     */
    where?: MaterialRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequests to fetch.
     */
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialRequests.
     */
    cursor?: MaterialRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialRequests.
     */
    distinct?: MaterialRequestScalarFieldEnum | MaterialRequestScalarFieldEnum[]
  }

  /**
   * MaterialRequest findMany
   */
  export type MaterialRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialRequests to fetch.
     */
    where?: MaterialRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialRequests to fetch.
     */
    orderBy?: MaterialRequestOrderByWithRelationInput | MaterialRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialRequests.
     */
    cursor?: MaterialRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialRequests.
     */
    skip?: number
    distinct?: MaterialRequestScalarFieldEnum | MaterialRequestScalarFieldEnum[]
  }

  /**
   * MaterialRequest create
   */
  export type MaterialRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialRequest.
     */
    data: XOR<MaterialRequestCreateInput, MaterialRequestUncheckedCreateInput>
  }

  /**
   * MaterialRequest createMany
   */
  export type MaterialRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialRequests.
     */
    data: MaterialRequestCreateManyInput | MaterialRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialRequest createManyAndReturn
   */
  export type MaterialRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MaterialRequests.
     */
    data: MaterialRequestCreateManyInput | MaterialRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialRequest update
   */
  export type MaterialRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialRequest.
     */
    data: XOR<MaterialRequestUpdateInput, MaterialRequestUncheckedUpdateInput>
    /**
     * Choose, which MaterialRequest to update.
     */
    where: MaterialRequestWhereUniqueInput
  }

  /**
   * MaterialRequest updateMany
   */
  export type MaterialRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialRequests.
     */
    data: XOR<MaterialRequestUpdateManyMutationInput, MaterialRequestUncheckedUpdateManyInput>
    /**
     * Filter which MaterialRequests to update
     */
    where?: MaterialRequestWhereInput
  }

  /**
   * MaterialRequest upsert
   */
  export type MaterialRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialRequest to update in case it exists.
     */
    where: MaterialRequestWhereUniqueInput
    /**
     * In case the MaterialRequest found by the `where` argument doesn't exist, create a new MaterialRequest with this data.
     */
    create: XOR<MaterialRequestCreateInput, MaterialRequestUncheckedCreateInput>
    /**
     * In case the MaterialRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialRequestUpdateInput, MaterialRequestUncheckedUpdateInput>
  }

  /**
   * MaterialRequest delete
   */
  export type MaterialRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
    /**
     * Filter which MaterialRequest to delete.
     */
    where: MaterialRequestWhereUniqueInput
  }

  /**
   * MaterialRequest deleteMany
   */
  export type MaterialRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialRequests to delete
     */
    where?: MaterialRequestWhereInput
  }

  /**
   * MaterialRequest without action
   */
  export type MaterialRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialRequest
     */
    select?: MaterialRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialRequestInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    conversationId: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    conversationId: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: number
    conversationId: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    conversationId?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    conversationId?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    conversationId?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string
    content: string
    conversationId: string | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    conversationId?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    conversationId?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    conversationId?: boolean
    createdAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string
      content: string
      conversationId: string | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly receiverId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model CommunicationRequest
   */

  export type AggregateCommunicationRequest = {
    _count: CommunicationRequestCountAggregateOutputType | null
    _min: CommunicationRequestMinAggregateOutputType | null
    _max: CommunicationRequestMaxAggregateOutputType | null
  }

  export type CommunicationRequestMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    requestType: $Enums.RequestType | null
    description: string | null
    urgency: string | null
    crewId: string | null
    estado: $Enums.RequestStatus | null
    respuesta: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunicationRequestMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    requestType: $Enums.RequestType | null
    description: string | null
    urgency: string | null
    crewId: string | null
    estado: $Enums.RequestStatus | null
    respuesta: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunicationRequestCountAggregateOutputType = {
    id: number
    senderId: number
    requestType: number
    description: number
    urgency: number
    crewId: number
    estado: number
    respuesta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunicationRequestMinAggregateInputType = {
    id?: true
    senderId?: true
    requestType?: true
    description?: true
    urgency?: true
    crewId?: true
    estado?: true
    respuesta?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunicationRequestMaxAggregateInputType = {
    id?: true
    senderId?: true
    requestType?: true
    description?: true
    urgency?: true
    crewId?: true
    estado?: true
    respuesta?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunicationRequestCountAggregateInputType = {
    id?: true
    senderId?: true
    requestType?: true
    description?: true
    urgency?: true
    crewId?: true
    estado?: true
    respuesta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunicationRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunicationRequest to aggregate.
     */
    where?: CommunicationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunicationRequests to fetch.
     */
    orderBy?: CommunicationRequestOrderByWithRelationInput | CommunicationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunicationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunicationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunicationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunicationRequests
    **/
    _count?: true | CommunicationRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunicationRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunicationRequestMaxAggregateInputType
  }

  export type GetCommunicationRequestAggregateType<T extends CommunicationRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunicationRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunicationRequest[P]>
      : GetScalarType<T[P], AggregateCommunicationRequest[P]>
  }




  export type CommunicationRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationRequestWhereInput
    orderBy?: CommunicationRequestOrderByWithAggregationInput | CommunicationRequestOrderByWithAggregationInput[]
    by: CommunicationRequestScalarFieldEnum[] | CommunicationRequestScalarFieldEnum
    having?: CommunicationRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunicationRequestCountAggregateInputType | true
    _min?: CommunicationRequestMinAggregateInputType
    _max?: CommunicationRequestMaxAggregateInputType
  }

  export type CommunicationRequestGroupByOutputType = {
    id: string
    senderId: string
    requestType: $Enums.RequestType
    description: string
    urgency: string
    crewId: string
    estado: $Enums.RequestStatus
    respuesta: string | null
    createdAt: Date
    updatedAt: Date
    _count: CommunicationRequestCountAggregateOutputType | null
    _min: CommunicationRequestMinAggregateOutputType | null
    _max: CommunicationRequestMaxAggregateOutputType | null
  }

  type GetCommunicationRequestGroupByPayload<T extends CommunicationRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunicationRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunicationRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunicationRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CommunicationRequestGroupByOutputType[P]>
        }
      >
    >


  export type CommunicationRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    requestType?: boolean
    description?: boolean
    urgency?: boolean
    crewId?: boolean
    estado?: boolean
    respuesta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communicationRequest"]>

  export type CommunicationRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    requestType?: boolean
    description?: boolean
    urgency?: boolean
    crewId?: boolean
    estado?: boolean
    respuesta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communicationRequest"]>

  export type CommunicationRequestSelectScalar = {
    id?: boolean
    senderId?: boolean
    requestType?: boolean
    description?: boolean
    urgency?: boolean
    crewId?: boolean
    estado?: boolean
    respuesta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunicationRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }
  export type CommunicationRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }

  export type $CommunicationRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunicationRequest"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      crew: Prisma.$CrewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      requestType: $Enums.RequestType
      description: string
      urgency: string
      crewId: string
      estado: $Enums.RequestStatus
      respuesta: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communicationRequest"]>
    composites: {}
  }

  type CommunicationRequestGetPayload<S extends boolean | null | undefined | CommunicationRequestDefaultArgs> = $Result.GetResult<Prisma.$CommunicationRequestPayload, S>

  type CommunicationRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunicationRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunicationRequestCountAggregateInputType | true
    }

  export interface CommunicationRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunicationRequest'], meta: { name: 'CommunicationRequest' } }
    /**
     * Find zero or one CommunicationRequest that matches the filter.
     * @param {CommunicationRequestFindUniqueArgs} args - Arguments to find a CommunicationRequest
     * @example
     * // Get one CommunicationRequest
     * const communicationRequest = await prisma.communicationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunicationRequestFindUniqueArgs>(args: SelectSubset<T, CommunicationRequestFindUniqueArgs<ExtArgs>>): Prisma__CommunicationRequestClient<$Result.GetResult<Prisma.$CommunicationRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommunicationRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommunicationRequestFindUniqueOrThrowArgs} args - Arguments to find a CommunicationRequest
     * @example
     * // Get one CommunicationRequest
     * const communicationRequest = await prisma.communicationRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunicationRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunicationRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunicationRequestClient<$Result.GetResult<Prisma.$CommunicationRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommunicationRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationRequestFindFirstArgs} args - Arguments to find a CommunicationRequest
     * @example
     * // Get one CommunicationRequest
     * const communicationRequest = await prisma.communicationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunicationRequestFindFirstArgs>(args?: SelectSubset<T, CommunicationRequestFindFirstArgs<ExtArgs>>): Prisma__CommunicationRequestClient<$Result.GetResult<Prisma.$CommunicationRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommunicationRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationRequestFindFirstOrThrowArgs} args - Arguments to find a CommunicationRequest
     * @example
     * // Get one CommunicationRequest
     * const communicationRequest = await prisma.communicationRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunicationRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunicationRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunicationRequestClient<$Result.GetResult<Prisma.$CommunicationRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommunicationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunicationRequests
     * const communicationRequests = await prisma.communicationRequest.findMany()
     * 
     * // Get first 10 CommunicationRequests
     * const communicationRequests = await prisma.communicationRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communicationRequestWithIdOnly = await prisma.communicationRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunicationRequestFindManyArgs>(args?: SelectSubset<T, CommunicationRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommunicationRequest.
     * @param {CommunicationRequestCreateArgs} args - Arguments to create a CommunicationRequest.
     * @example
     * // Create one CommunicationRequest
     * const CommunicationRequest = await prisma.communicationRequest.create({
     *   data: {
     *     // ... data to create a CommunicationRequest
     *   }
     * })
     * 
     */
    create<T extends CommunicationRequestCreateArgs>(args: SelectSubset<T, CommunicationRequestCreateArgs<ExtArgs>>): Prisma__CommunicationRequestClient<$Result.GetResult<Prisma.$CommunicationRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommunicationRequests.
     * @param {CommunicationRequestCreateManyArgs} args - Arguments to create many CommunicationRequests.
     * @example
     * // Create many CommunicationRequests
     * const communicationRequest = await prisma.communicationRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunicationRequestCreateManyArgs>(args?: SelectSubset<T, CommunicationRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunicationRequests and returns the data saved in the database.
     * @param {CommunicationRequestCreateManyAndReturnArgs} args - Arguments to create many CommunicationRequests.
     * @example
     * // Create many CommunicationRequests
     * const communicationRequest = await prisma.communicationRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunicationRequests and only return the `id`
     * const communicationRequestWithIdOnly = await prisma.communicationRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunicationRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunicationRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommunicationRequest.
     * @param {CommunicationRequestDeleteArgs} args - Arguments to delete one CommunicationRequest.
     * @example
     * // Delete one CommunicationRequest
     * const CommunicationRequest = await prisma.communicationRequest.delete({
     *   where: {
     *     // ... filter to delete one CommunicationRequest
     *   }
     * })
     * 
     */
    delete<T extends CommunicationRequestDeleteArgs>(args: SelectSubset<T, CommunicationRequestDeleteArgs<ExtArgs>>): Prisma__CommunicationRequestClient<$Result.GetResult<Prisma.$CommunicationRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommunicationRequest.
     * @param {CommunicationRequestUpdateArgs} args - Arguments to update one CommunicationRequest.
     * @example
     * // Update one CommunicationRequest
     * const communicationRequest = await prisma.communicationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunicationRequestUpdateArgs>(args: SelectSubset<T, CommunicationRequestUpdateArgs<ExtArgs>>): Prisma__CommunicationRequestClient<$Result.GetResult<Prisma.$CommunicationRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommunicationRequests.
     * @param {CommunicationRequestDeleteManyArgs} args - Arguments to filter CommunicationRequests to delete.
     * @example
     * // Delete a few CommunicationRequests
     * const { count } = await prisma.communicationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunicationRequestDeleteManyArgs>(args?: SelectSubset<T, CommunicationRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunicationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunicationRequests
     * const communicationRequest = await prisma.communicationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunicationRequestUpdateManyArgs>(args: SelectSubset<T, CommunicationRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunicationRequest.
     * @param {CommunicationRequestUpsertArgs} args - Arguments to update or create a CommunicationRequest.
     * @example
     * // Update or create a CommunicationRequest
     * const communicationRequest = await prisma.communicationRequest.upsert({
     *   create: {
     *     // ... data to create a CommunicationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunicationRequest we want to update
     *   }
     * })
     */
    upsert<T extends CommunicationRequestUpsertArgs>(args: SelectSubset<T, CommunicationRequestUpsertArgs<ExtArgs>>): Prisma__CommunicationRequestClient<$Result.GetResult<Prisma.$CommunicationRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommunicationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationRequestCountArgs} args - Arguments to filter CommunicationRequests to count.
     * @example
     * // Count the number of CommunicationRequests
     * const count = await prisma.communicationRequest.count({
     *   where: {
     *     // ... the filter for the CommunicationRequests we want to count
     *   }
     * })
    **/
    count<T extends CommunicationRequestCountArgs>(
      args?: Subset<T, CommunicationRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunicationRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunicationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunicationRequestAggregateArgs>(args: Subset<T, CommunicationRequestAggregateArgs>): Prisma.PrismaPromise<GetCommunicationRequestAggregateType<T>>

    /**
     * Group by CommunicationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunicationRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunicationRequestGroupByArgs['orderBy'] }
        : { orderBy?: CommunicationRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunicationRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunicationRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunicationRequest model
   */
  readonly fields: CommunicationRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunicationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunicationRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    crew<T extends CrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewDefaultArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunicationRequest model
   */ 
  interface CommunicationRequestFieldRefs {
    readonly id: FieldRef<"CommunicationRequest", 'String'>
    readonly senderId: FieldRef<"CommunicationRequest", 'String'>
    readonly requestType: FieldRef<"CommunicationRequest", 'RequestType'>
    readonly description: FieldRef<"CommunicationRequest", 'String'>
    readonly urgency: FieldRef<"CommunicationRequest", 'String'>
    readonly crewId: FieldRef<"CommunicationRequest", 'String'>
    readonly estado: FieldRef<"CommunicationRequest", 'RequestStatus'>
    readonly respuesta: FieldRef<"CommunicationRequest", 'String'>
    readonly createdAt: FieldRef<"CommunicationRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"CommunicationRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunicationRequest findUnique
   */
  export type CommunicationRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationRequest to fetch.
     */
    where: CommunicationRequestWhereUniqueInput
  }

  /**
   * CommunicationRequest findUniqueOrThrow
   */
  export type CommunicationRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationRequest to fetch.
     */
    where: CommunicationRequestWhereUniqueInput
  }

  /**
   * CommunicationRequest findFirst
   */
  export type CommunicationRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationRequest to fetch.
     */
    where?: CommunicationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunicationRequests to fetch.
     */
    orderBy?: CommunicationRequestOrderByWithRelationInput | CommunicationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunicationRequests.
     */
    cursor?: CommunicationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunicationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunicationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunicationRequests.
     */
    distinct?: CommunicationRequestScalarFieldEnum | CommunicationRequestScalarFieldEnum[]
  }

  /**
   * CommunicationRequest findFirstOrThrow
   */
  export type CommunicationRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationRequest to fetch.
     */
    where?: CommunicationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunicationRequests to fetch.
     */
    orderBy?: CommunicationRequestOrderByWithRelationInput | CommunicationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunicationRequests.
     */
    cursor?: CommunicationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunicationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunicationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunicationRequests.
     */
    distinct?: CommunicationRequestScalarFieldEnum | CommunicationRequestScalarFieldEnum[]
  }

  /**
   * CommunicationRequest findMany
   */
  export type CommunicationRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationRequests to fetch.
     */
    where?: CommunicationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunicationRequests to fetch.
     */
    orderBy?: CommunicationRequestOrderByWithRelationInput | CommunicationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunicationRequests.
     */
    cursor?: CommunicationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunicationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunicationRequests.
     */
    skip?: number
    distinct?: CommunicationRequestScalarFieldEnum | CommunicationRequestScalarFieldEnum[]
  }

  /**
   * CommunicationRequest create
   */
  export type CommunicationRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunicationRequest.
     */
    data: XOR<CommunicationRequestCreateInput, CommunicationRequestUncheckedCreateInput>
  }

  /**
   * CommunicationRequest createMany
   */
  export type CommunicationRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunicationRequests.
     */
    data: CommunicationRequestCreateManyInput | CommunicationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunicationRequest createManyAndReturn
   */
  export type CommunicationRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommunicationRequests.
     */
    data: CommunicationRequestCreateManyInput | CommunicationRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunicationRequest update
   */
  export type CommunicationRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunicationRequest.
     */
    data: XOR<CommunicationRequestUpdateInput, CommunicationRequestUncheckedUpdateInput>
    /**
     * Choose, which CommunicationRequest to update.
     */
    where: CommunicationRequestWhereUniqueInput
  }

  /**
   * CommunicationRequest updateMany
   */
  export type CommunicationRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunicationRequests.
     */
    data: XOR<CommunicationRequestUpdateManyMutationInput, CommunicationRequestUncheckedUpdateManyInput>
    /**
     * Filter which CommunicationRequests to update
     */
    where?: CommunicationRequestWhereInput
  }

  /**
   * CommunicationRequest upsert
   */
  export type CommunicationRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunicationRequest to update in case it exists.
     */
    where: CommunicationRequestWhereUniqueInput
    /**
     * In case the CommunicationRequest found by the `where` argument doesn't exist, create a new CommunicationRequest with this data.
     */
    create: XOR<CommunicationRequestCreateInput, CommunicationRequestUncheckedCreateInput>
    /**
     * In case the CommunicationRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunicationRequestUpdateInput, CommunicationRequestUncheckedUpdateInput>
  }

  /**
   * CommunicationRequest delete
   */
  export type CommunicationRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestInclude<ExtArgs> | null
    /**
     * Filter which CommunicationRequest to delete.
     */
    where: CommunicationRequestWhereUniqueInput
  }

  /**
   * CommunicationRequest deleteMany
   */
  export type CommunicationRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunicationRequests to delete
     */
    where?: CommunicationRequestWhereInput
  }

  /**
   * CommunicationRequest without action
   */
  export type CommunicationRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationRequest
     */
    select?: CommunicationRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationRequestInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    _all: number
  }


  export type CertificateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    _count: CertificateCountAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    workers?: boolean | Certificate$workersArgs<ExtArgs>
    _count?: boolean | CertificateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workers?: boolean | Certificate$workersArgs<ExtArgs>
    _count?: boolean | CertificateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      workers: Prisma.$WorkerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workers<T extends Certificate$workersArgs<ExtArgs> = {}>(args?: Subset<T, Certificate$workersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */ 
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'String'>
    readonly name: FieldRef<"Certificate", 'String'>
    readonly description: FieldRef<"Certificate", 'String'>
    readonly createdAt: FieldRef<"Certificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate.workers
   */
  export type Certificate$workersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    cursor?: WorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    targetDate: Date | null
    estado: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    targetDate: Date | null
    estado: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    description: number
    targetDate: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MilestoneMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    targetDate?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    targetDate?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    targetDate?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: string
    projectId: string
    title: string
    description: string | null
    targetDate: Date
    estado: string
    createdAt: Date
    updatedAt: Date
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    targetDate?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    targetDate?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    targetDate?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      title: string
      description: string | null
      targetDate: Date
      estado: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }

  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilestoneFindUniqueArgs>(args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Milestone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilestoneFindFirstArgs>(args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilestoneFindManyArgs>(args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
     */
    create<T extends MilestoneCreateArgs>(args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Milestones.
     * @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilestoneCreateManyArgs>(args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Milestones and returns the data saved in the database.
     * @param {MilestoneCreateManyAndReturnArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, MilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
     */
    delete<T extends MilestoneDeleteArgs>(args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilestoneUpdateArgs>(args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilestoneDeleteManyArgs>(args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilestoneUpdateManyArgs>(args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
     */
    upsert<T extends MilestoneUpsertArgs>(args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Milestone model
   */ 
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'String'>
    readonly projectId: FieldRef<"Milestone", 'String'>
    readonly title: FieldRef<"Milestone", 'String'>
    readonly description: FieldRef<"Milestone", 'String'>
    readonly targetDate: FieldRef<"Milestone", 'DateTime'>
    readonly estado: FieldRef<"Milestone", 'String'>
    readonly createdAt: FieldRef<"Milestone", 'DateTime'>
    readonly updatedAt: FieldRef<"Milestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }

  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Milestone createManyAndReturn
   */
  export type MilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
  }

  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }

  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
  }

  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    crewId: string | null
    title: string | null
    description: string | null
    prioridad: string | null
    estado: string | null
    fecha_vencimiento: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    crewId: string | null
    title: string | null
    description: string | null
    prioridad: string | null
    estado: string | null
    fecha_vencimiento: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    crewId: number
    title: number
    description: number
    prioridad: number
    estado: number
    fecha_vencimiento: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    crewId?: true
    title?: true
    description?: true
    prioridad?: true
    estado?: true
    fecha_vencimiento?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    crewId?: true
    title?: true
    description?: true
    prioridad?: true
    estado?: true
    fecha_vencimiento?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    crewId?: true
    title?: true
    description?: true
    prioridad?: true
    estado?: true
    fecha_vencimiento?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    crewId: string
    title: string
    description: string | null
    prioridad: string
    estado: string
    fecha_vencimiento: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    crewId?: boolean
    title?: boolean
    description?: boolean
    prioridad?: boolean
    estado?: boolean
    fecha_vencimiento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    crewId?: boolean
    title?: boolean
    description?: boolean
    prioridad?: boolean
    estado?: boolean
    fecha_vencimiento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    crewId?: boolean
    title?: boolean
    description?: boolean
    prioridad?: boolean
    estado?: boolean
    fecha_vencimiento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      crew: Prisma.$CrewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      crewId: string
      title: string
      description: string | null
      prioridad: string
      estado: string
      fecha_vencimiento: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crew<T extends CrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewDefaultArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly crewId: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly prioridad: FieldRef<"Task", 'String'>
    readonly estado: FieldRef<"Task", 'String'>
    readonly fecha_vencimiento: FieldRef<"Task", 'DateTime'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    projectId: string | null
    changes: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    projectId: string | null
    changes: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    projectId: number
    changes: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    projectId?: true
    changes?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    projectId?: true
    changes?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    projectId?: true
    changes?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entity: string
    entityId: string | null
    projectId: string | null
    changes: string | null
    ipAddress: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    projectId?: boolean
    changes?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    project?: boolean | AuditLog$projectArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    projectId?: boolean
    changes?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    project?: boolean | AuditLog$projectArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    projectId?: boolean
    changes?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | AuditLog$projectArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | AuditLog$projectArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entity: string
      entityId: string | null
      projectId: string | null
      changes: string | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends AuditLog$projectArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly projectId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.project
   */
  export type AuditLog$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tipo_obra: 'tipo_obra',
    complejidad: 'complejidad',
    duracion_estimada: 'duracion_estimada',
    fecha_inicio: 'fecha_inicio',
    fecha_termino: 'fecha_termino',
    zona_trabajo: 'zona_trabajo',
    estado: 'estado',
    presupuesto: 'presupuesto',
    supervisor: 'supervisor',
    descripcion_tecnica: 'descripcion_tecnica',
    jefeId: 'jefeId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const WorkerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    rut: 'rut',
    especialidad: 'especialidad',
    certificaciones: 'certificaciones',
    experiencia: 'experiencia',
    disponibilidad: 'disponibilidad',
    estado: 'estado',
    zona_preferencia: 'zona_preferencia'
  };

  export type WorkerScalarFieldEnum = (typeof WorkerScalarFieldEnum)[keyof typeof WorkerScalarFieldEnum]


  export const CrewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    projectId: 'projectId',
    fecha_inicio: 'fecha_inicio',
    estado: 'estado',
    zona_trabajo: 'zona_trabajo',
    fecha_plazo: 'fecha_plazo',
    cantidad_trabajadores: 'cantidad_trabajadores'
  };

  export type CrewScalarFieldEnum = (typeof CrewScalarFieldEnum)[keyof typeof CrewScalarFieldEnum]


  export const CrewWorkerScalarFieldEnum: {
    id: 'id',
    crewId: 'crewId',
    workerId: 'workerId',
    role: 'role',
    fecha_asignacion: 'fecha_asignacion'
  };

  export type CrewWorkerScalarFieldEnum = (typeof CrewWorkerScalarFieldEnum)[keyof typeof CrewWorkerScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    crewId: 'crewId',
    projectId: 'projectId',
    descripcion: 'descripcion',
    incidentes: 'incidentes',
    consumo_materiales: 'consumo_materiales',
    avance: 'avance',
    fecha: 'fecha',
    responsableId: 'responsableId',
    actividades: 'actividades',
    materiales_consumidos: 'materiales_consumidos',
    tiempos_trabajo: 'tiempos_trabajo',
    observaciones: 'observaciones',
    estado_herramientas: 'estado_herramientas'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    descripcion: 'descripcion',
    stock: 'stock',
    unidad: 'unidad',
    precio: 'precio'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const MaterialRequestScalarFieldEnum: {
    id: 'id',
    materialId: 'materialId',
    projectId: 'projectId',
    crewId: 'crewId',
    cantidad: 'cantidad',
    estado: 'estado',
    createdAt: 'createdAt'
  };

  export type MaterialRequestScalarFieldEnum = (typeof MaterialRequestScalarFieldEnum)[keyof typeof MaterialRequestScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    conversationId: 'conversationId',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const CommunicationRequestScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    requestType: 'requestType',
    description: 'description',
    urgency: 'urgency',
    crewId: 'crewId',
    estado: 'estado',
    respuesta: 'respuesta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunicationRequestScalarFieldEnum = (typeof CommunicationRequestScalarFieldEnum)[keyof typeof CommunicationRequestScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    targetDate: 'targetDate',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    crewId: 'crewId',
    title: 'title',
    description: 'description',
    prioridad: 'prioridad',
    estado: 'estado',
    fecha_vencimiento: 'fecha_vencimiento',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    projectId: 'projectId',
    changes: 'changes',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CrewState'
   */
  export type EnumCrewStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CrewState'>
    


  /**
   * Reference to a field of type 'CrewState[]'
   */
  export type ListEnumCrewStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CrewState[]'>
    


  /**
   * Reference to a field of type 'MaterialRequestState'
   */
  export type EnumMaterialRequestStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialRequestState'>
    


  /**
   * Reference to a field of type 'MaterialRequestState[]'
   */
  export type ListEnumMaterialRequestStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialRequestState[]'>
    


  /**
   * Reference to a field of type 'RequestType'
   */
  export type EnumRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestType'>
    


  /**
   * Reference to a field of type 'RequestType[]'
   */
  export type ListEnumRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestType[]'>
    


  /**
   * Reference to a field of type 'RequestStatus'
   */
  export type EnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus'>
    


  /**
   * Reference to a field of type 'RequestStatus[]'
   */
  export type ListEnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    projects?: ProjectListRelationFilter
    logs?: LogListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    requests?: CommunicationRequestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    requests?: CommunicationRequestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    projects?: ProjectListRelationFilter
    logs?: LogListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    requests?: CommunicationRequestListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    tipo_obra?: StringFilter<"Project"> | string
    complejidad?: StringFilter<"Project"> | string
    duracion_estimada?: IntNullableFilter<"Project"> | number | null
    fecha_inicio?: DateTimeNullableFilter<"Project"> | Date | string | null
    fecha_termino?: DateTimeNullableFilter<"Project"> | Date | string | null
    zona_trabajo?: StringFilter<"Project"> | string
    estado?: StringFilter<"Project"> | string
    presupuesto?: FloatNullableFilter<"Project"> | number | null
    supervisor?: StringNullableFilter<"Project"> | string | null
    descripcion_tecnica?: StringNullableFilter<"Project"> | string | null
    jefeId?: StringNullableFilter<"Project"> | string | null
    jefe?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    crews?: CrewListRelationFilter
    materialRequests?: MaterialRequestListRelationFilter
    logs?: LogListRelationFilter
    milestones?: MilestoneListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tipo_obra?: SortOrder
    complejidad?: SortOrder
    duracion_estimada?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_termino?: SortOrderInput | SortOrder
    zona_trabajo?: SortOrder
    estado?: SortOrder
    presupuesto?: SortOrderInput | SortOrder
    supervisor?: SortOrderInput | SortOrder
    descripcion_tecnica?: SortOrderInput | SortOrder
    jefeId?: SortOrderInput | SortOrder
    jefe?: UserOrderByWithRelationInput
    crews?: CrewOrderByRelationAggregateInput
    materialRequests?: MaterialRequestOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    milestones?: MilestoneOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    tipo_obra?: StringFilter<"Project"> | string
    complejidad?: StringFilter<"Project"> | string
    duracion_estimada?: IntNullableFilter<"Project"> | number | null
    fecha_inicio?: DateTimeNullableFilter<"Project"> | Date | string | null
    fecha_termino?: DateTimeNullableFilter<"Project"> | Date | string | null
    zona_trabajo?: StringFilter<"Project"> | string
    estado?: StringFilter<"Project"> | string
    presupuesto?: FloatNullableFilter<"Project"> | number | null
    supervisor?: StringNullableFilter<"Project"> | string | null
    descripcion_tecnica?: StringNullableFilter<"Project"> | string | null
    jefeId?: StringNullableFilter<"Project"> | string | null
    jefe?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    crews?: CrewListRelationFilter
    materialRequests?: MaterialRequestListRelationFilter
    logs?: LogListRelationFilter
    milestones?: MilestoneListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tipo_obra?: SortOrder
    complejidad?: SortOrder
    duracion_estimada?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_termino?: SortOrderInput | SortOrder
    zona_trabajo?: SortOrder
    estado?: SortOrder
    presupuesto?: SortOrderInput | SortOrder
    supervisor?: SortOrderInput | SortOrder
    descripcion_tecnica?: SortOrderInput | SortOrder
    jefeId?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    tipo_obra?: StringWithAggregatesFilter<"Project"> | string
    complejidad?: StringWithAggregatesFilter<"Project"> | string
    duracion_estimada?: IntNullableWithAggregatesFilter<"Project"> | number | null
    fecha_inicio?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    fecha_termino?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    zona_trabajo?: StringWithAggregatesFilter<"Project"> | string
    estado?: StringWithAggregatesFilter<"Project"> | string
    presupuesto?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    supervisor?: StringNullableWithAggregatesFilter<"Project"> | string | null
    descripcion_tecnica?: StringNullableWithAggregatesFilter<"Project"> | string | null
    jefeId?: StringNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type WorkerWhereInput = {
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    id?: StringFilter<"Worker"> | string
    name?: StringFilter<"Worker"> | string
    rut?: StringNullableFilter<"Worker"> | string | null
    especialidad?: StringFilter<"Worker"> | string
    certificaciones?: StringNullableFilter<"Worker"> | string | null
    experiencia?: IntNullableFilter<"Worker"> | number | null
    disponibilidad?: BoolFilter<"Worker"> | boolean
    estado?: StringFilter<"Worker"> | string
    zona_preferencia?: StringNullableFilter<"Worker"> | string | null
    crewWorkers?: CrewWorkerListRelationFilter
    certificates?: CertificateListRelationFilter
  }

  export type WorkerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    rut?: SortOrderInput | SortOrder
    especialidad?: SortOrder
    certificaciones?: SortOrderInput | SortOrder
    experiencia?: SortOrderInput | SortOrder
    disponibilidad?: SortOrder
    estado?: SortOrder
    zona_preferencia?: SortOrderInput | SortOrder
    crewWorkers?: CrewWorkerOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
  }

  export type WorkerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rut?: string
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    name?: StringFilter<"Worker"> | string
    especialidad?: StringFilter<"Worker"> | string
    certificaciones?: StringNullableFilter<"Worker"> | string | null
    experiencia?: IntNullableFilter<"Worker"> | number | null
    disponibilidad?: BoolFilter<"Worker"> | boolean
    estado?: StringFilter<"Worker"> | string
    zona_preferencia?: StringNullableFilter<"Worker"> | string | null
    crewWorkers?: CrewWorkerListRelationFilter
    certificates?: CertificateListRelationFilter
  }, "id" | "rut">

  export type WorkerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    rut?: SortOrderInput | SortOrder
    especialidad?: SortOrder
    certificaciones?: SortOrderInput | SortOrder
    experiencia?: SortOrderInput | SortOrder
    disponibilidad?: SortOrder
    estado?: SortOrder
    zona_preferencia?: SortOrderInput | SortOrder
    _count?: WorkerCountOrderByAggregateInput
    _avg?: WorkerAvgOrderByAggregateInput
    _max?: WorkerMaxOrderByAggregateInput
    _min?: WorkerMinOrderByAggregateInput
    _sum?: WorkerSumOrderByAggregateInput
  }

  export type WorkerScalarWhereWithAggregatesInput = {
    AND?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    OR?: WorkerScalarWhereWithAggregatesInput[]
    NOT?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Worker"> | string
    name?: StringWithAggregatesFilter<"Worker"> | string
    rut?: StringNullableWithAggregatesFilter<"Worker"> | string | null
    especialidad?: StringWithAggregatesFilter<"Worker"> | string
    certificaciones?: StringNullableWithAggregatesFilter<"Worker"> | string | null
    experiencia?: IntNullableWithAggregatesFilter<"Worker"> | number | null
    disponibilidad?: BoolWithAggregatesFilter<"Worker"> | boolean
    estado?: StringWithAggregatesFilter<"Worker"> | string
    zona_preferencia?: StringNullableWithAggregatesFilter<"Worker"> | string | null
  }

  export type CrewWhereInput = {
    AND?: CrewWhereInput | CrewWhereInput[]
    OR?: CrewWhereInput[]
    NOT?: CrewWhereInput | CrewWhereInput[]
    id?: StringFilter<"Crew"> | string
    name?: StringFilter<"Crew"> | string
    projectId?: StringNullableFilter<"Crew"> | string | null
    fecha_inicio?: DateTimeNullableFilter<"Crew"> | Date | string | null
    estado?: EnumCrewStateFilter<"Crew"> | $Enums.CrewState
    zona_trabajo?: StringNullableFilter<"Crew"> | string | null
    fecha_plazo?: DateTimeNullableFilter<"Crew"> | Date | string | null
    cantidad_trabajadores?: IntNullableFilter<"Crew"> | number | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    crewWorkers?: CrewWorkerListRelationFilter
    logs?: LogListRelationFilter
    materialRequests?: MaterialRequestListRelationFilter
    communicationRequests?: CommunicationRequestListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type CrewOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    projectId?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    estado?: SortOrder
    zona_trabajo?: SortOrderInput | SortOrder
    fecha_plazo?: SortOrderInput | SortOrder
    cantidad_trabajadores?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    crewWorkers?: CrewWorkerOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    materialRequests?: MaterialRequestOrderByRelationAggregateInput
    communicationRequests?: CommunicationRequestOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type CrewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrewWhereInput | CrewWhereInput[]
    OR?: CrewWhereInput[]
    NOT?: CrewWhereInput | CrewWhereInput[]
    name?: StringFilter<"Crew"> | string
    projectId?: StringNullableFilter<"Crew"> | string | null
    fecha_inicio?: DateTimeNullableFilter<"Crew"> | Date | string | null
    estado?: EnumCrewStateFilter<"Crew"> | $Enums.CrewState
    zona_trabajo?: StringNullableFilter<"Crew"> | string | null
    fecha_plazo?: DateTimeNullableFilter<"Crew"> | Date | string | null
    cantidad_trabajadores?: IntNullableFilter<"Crew"> | number | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    crewWorkers?: CrewWorkerListRelationFilter
    logs?: LogListRelationFilter
    materialRequests?: MaterialRequestListRelationFilter
    communicationRequests?: CommunicationRequestListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id">

  export type CrewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    projectId?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    estado?: SortOrder
    zona_trabajo?: SortOrderInput | SortOrder
    fecha_plazo?: SortOrderInput | SortOrder
    cantidad_trabajadores?: SortOrderInput | SortOrder
    _count?: CrewCountOrderByAggregateInput
    _avg?: CrewAvgOrderByAggregateInput
    _max?: CrewMaxOrderByAggregateInput
    _min?: CrewMinOrderByAggregateInput
    _sum?: CrewSumOrderByAggregateInput
  }

  export type CrewScalarWhereWithAggregatesInput = {
    AND?: CrewScalarWhereWithAggregatesInput | CrewScalarWhereWithAggregatesInput[]
    OR?: CrewScalarWhereWithAggregatesInput[]
    NOT?: CrewScalarWhereWithAggregatesInput | CrewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Crew"> | string
    name?: StringWithAggregatesFilter<"Crew"> | string
    projectId?: StringNullableWithAggregatesFilter<"Crew"> | string | null
    fecha_inicio?: DateTimeNullableWithAggregatesFilter<"Crew"> | Date | string | null
    estado?: EnumCrewStateWithAggregatesFilter<"Crew"> | $Enums.CrewState
    zona_trabajo?: StringNullableWithAggregatesFilter<"Crew"> | string | null
    fecha_plazo?: DateTimeNullableWithAggregatesFilter<"Crew"> | Date | string | null
    cantidad_trabajadores?: IntNullableWithAggregatesFilter<"Crew"> | number | null
  }

  export type CrewWorkerWhereInput = {
    AND?: CrewWorkerWhereInput | CrewWorkerWhereInput[]
    OR?: CrewWorkerWhereInput[]
    NOT?: CrewWorkerWhereInput | CrewWorkerWhereInput[]
    id?: StringFilter<"CrewWorker"> | string
    crewId?: StringFilter<"CrewWorker"> | string
    workerId?: StringFilter<"CrewWorker"> | string
    role?: StringFilter<"CrewWorker"> | string
    fecha_asignacion?: DateTimeFilter<"CrewWorker"> | Date | string
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
    worker?: XOR<WorkerRelationFilter, WorkerWhereInput>
  }

  export type CrewWorkerOrderByWithRelationInput = {
    id?: SortOrder
    crewId?: SortOrder
    workerId?: SortOrder
    role?: SortOrder
    fecha_asignacion?: SortOrder
    crew?: CrewOrderByWithRelationInput
    worker?: WorkerOrderByWithRelationInput
  }

  export type CrewWorkerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrewWorkerWhereInput | CrewWorkerWhereInput[]
    OR?: CrewWorkerWhereInput[]
    NOT?: CrewWorkerWhereInput | CrewWorkerWhereInput[]
    crewId?: StringFilter<"CrewWorker"> | string
    workerId?: StringFilter<"CrewWorker"> | string
    role?: StringFilter<"CrewWorker"> | string
    fecha_asignacion?: DateTimeFilter<"CrewWorker"> | Date | string
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
    worker?: XOR<WorkerRelationFilter, WorkerWhereInput>
  }, "id">

  export type CrewWorkerOrderByWithAggregationInput = {
    id?: SortOrder
    crewId?: SortOrder
    workerId?: SortOrder
    role?: SortOrder
    fecha_asignacion?: SortOrder
    _count?: CrewWorkerCountOrderByAggregateInput
    _max?: CrewWorkerMaxOrderByAggregateInput
    _min?: CrewWorkerMinOrderByAggregateInput
  }

  export type CrewWorkerScalarWhereWithAggregatesInput = {
    AND?: CrewWorkerScalarWhereWithAggregatesInput | CrewWorkerScalarWhereWithAggregatesInput[]
    OR?: CrewWorkerScalarWhereWithAggregatesInput[]
    NOT?: CrewWorkerScalarWhereWithAggregatesInput | CrewWorkerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrewWorker"> | string
    crewId?: StringWithAggregatesFilter<"CrewWorker"> | string
    workerId?: StringWithAggregatesFilter<"CrewWorker"> | string
    role?: StringWithAggregatesFilter<"CrewWorker"> | string
    fecha_asignacion?: DateTimeWithAggregatesFilter<"CrewWorker"> | Date | string
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: StringFilter<"Log"> | string
    crewId?: StringFilter<"Log"> | string
    projectId?: StringFilter<"Log"> | string
    descripcion?: StringNullableFilter<"Log"> | string | null
    incidentes?: StringNullableFilter<"Log"> | string | null
    consumo_materiales?: StringNullableFilter<"Log"> | string | null
    avance?: StringNullableFilter<"Log"> | string | null
    fecha?: DateTimeFilter<"Log"> | Date | string
    responsableId?: StringFilter<"Log"> | string
    actividades?: StringNullableFilter<"Log"> | string | null
    materiales_consumidos?: StringNullableFilter<"Log"> | string | null
    tiempos_trabajo?: StringNullableFilter<"Log"> | string | null
    observaciones?: StringNullableFilter<"Log"> | string | null
    estado_herramientas?: StringNullableFilter<"Log"> | string | null
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    responsable?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    crewId?: SortOrder
    projectId?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    incidentes?: SortOrderInput | SortOrder
    consumo_materiales?: SortOrderInput | SortOrder
    avance?: SortOrderInput | SortOrder
    fecha?: SortOrder
    responsableId?: SortOrder
    actividades?: SortOrderInput | SortOrder
    materiales_consumidos?: SortOrderInput | SortOrder
    tiempos_trabajo?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    estado_herramientas?: SortOrderInput | SortOrder
    crew?: CrewOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    responsable?: UserOrderByWithRelationInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    crewId?: StringFilter<"Log"> | string
    projectId?: StringFilter<"Log"> | string
    descripcion?: StringNullableFilter<"Log"> | string | null
    incidentes?: StringNullableFilter<"Log"> | string | null
    consumo_materiales?: StringNullableFilter<"Log"> | string | null
    avance?: StringNullableFilter<"Log"> | string | null
    fecha?: DateTimeFilter<"Log"> | Date | string
    responsableId?: StringFilter<"Log"> | string
    actividades?: StringNullableFilter<"Log"> | string | null
    materiales_consumidos?: StringNullableFilter<"Log"> | string | null
    tiempos_trabajo?: StringNullableFilter<"Log"> | string | null
    observaciones?: StringNullableFilter<"Log"> | string | null
    estado_herramientas?: StringNullableFilter<"Log"> | string | null
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    responsable?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    crewId?: SortOrder
    projectId?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    incidentes?: SortOrderInput | SortOrder
    consumo_materiales?: SortOrderInput | SortOrder
    avance?: SortOrderInput | SortOrder
    fecha?: SortOrder
    responsableId?: SortOrder
    actividades?: SortOrderInput | SortOrder
    materiales_consumidos?: SortOrderInput | SortOrder
    tiempos_trabajo?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    estado_herramientas?: SortOrderInput | SortOrder
    _count?: LogCountOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Log"> | string
    crewId?: StringWithAggregatesFilter<"Log"> | string
    projectId?: StringWithAggregatesFilter<"Log"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Log"> | string | null
    incidentes?: StringNullableWithAggregatesFilter<"Log"> | string | null
    consumo_materiales?: StringNullableWithAggregatesFilter<"Log"> | string | null
    avance?: StringNullableWithAggregatesFilter<"Log"> | string | null
    fecha?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    responsableId?: StringWithAggregatesFilter<"Log"> | string
    actividades?: StringNullableWithAggregatesFilter<"Log"> | string | null
    materiales_consumidos?: StringNullableWithAggregatesFilter<"Log"> | string | null
    tiempos_trabajo?: StringNullableWithAggregatesFilter<"Log"> | string | null
    observaciones?: StringNullableWithAggregatesFilter<"Log"> | string | null
    estado_herramientas?: StringNullableWithAggregatesFilter<"Log"> | string | null
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: StringFilter<"Material"> | string
    name?: StringFilter<"Material"> | string
    descripcion?: StringNullableFilter<"Material"> | string | null
    stock?: IntFilter<"Material"> | number
    unidad?: StringFilter<"Material"> | string
    precio?: FloatFilter<"Material"> | number
    requests?: MaterialRequestListRelationFilter
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    stock?: SortOrder
    unidad?: SortOrder
    precio?: SortOrder
    requests?: MaterialRequestOrderByRelationAggregateInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    name?: StringFilter<"Material"> | string
    descripcion?: StringNullableFilter<"Material"> | string | null
    stock?: IntFilter<"Material"> | number
    unidad?: StringFilter<"Material"> | string
    precio?: FloatFilter<"Material"> | number
    requests?: MaterialRequestListRelationFilter
  }, "id">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    stock?: SortOrder
    unidad?: SortOrder
    precio?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Material"> | string
    name?: StringWithAggregatesFilter<"Material"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Material"> | string | null
    stock?: IntWithAggregatesFilter<"Material"> | number
    unidad?: StringWithAggregatesFilter<"Material"> | string
    precio?: FloatWithAggregatesFilter<"Material"> | number
  }

  export type MaterialRequestWhereInput = {
    AND?: MaterialRequestWhereInput | MaterialRequestWhereInput[]
    OR?: MaterialRequestWhereInput[]
    NOT?: MaterialRequestWhereInput | MaterialRequestWhereInput[]
    id?: StringFilter<"MaterialRequest"> | string
    materialId?: StringFilter<"MaterialRequest"> | string
    projectId?: StringFilter<"MaterialRequest"> | string
    crewId?: StringFilter<"MaterialRequest"> | string
    cantidad?: IntFilter<"MaterialRequest"> | number
    estado?: EnumMaterialRequestStateFilter<"MaterialRequest"> | $Enums.MaterialRequestState
    createdAt?: DateTimeFilter<"MaterialRequest"> | Date | string
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }

  export type MaterialRequestOrderByWithRelationInput = {
    id?: SortOrder
    materialId?: SortOrder
    projectId?: SortOrder
    crewId?: SortOrder
    cantidad?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    material?: MaterialOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    crew?: CrewOrderByWithRelationInput
  }

  export type MaterialRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaterialRequestWhereInput | MaterialRequestWhereInput[]
    OR?: MaterialRequestWhereInput[]
    NOT?: MaterialRequestWhereInput | MaterialRequestWhereInput[]
    materialId?: StringFilter<"MaterialRequest"> | string
    projectId?: StringFilter<"MaterialRequest"> | string
    crewId?: StringFilter<"MaterialRequest"> | string
    cantidad?: IntFilter<"MaterialRequest"> | number
    estado?: EnumMaterialRequestStateFilter<"MaterialRequest"> | $Enums.MaterialRequestState
    createdAt?: DateTimeFilter<"MaterialRequest"> | Date | string
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }, "id">

  export type MaterialRequestOrderByWithAggregationInput = {
    id?: SortOrder
    materialId?: SortOrder
    projectId?: SortOrder
    crewId?: SortOrder
    cantidad?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    _count?: MaterialRequestCountOrderByAggregateInput
    _avg?: MaterialRequestAvgOrderByAggregateInput
    _max?: MaterialRequestMaxOrderByAggregateInput
    _min?: MaterialRequestMinOrderByAggregateInput
    _sum?: MaterialRequestSumOrderByAggregateInput
  }

  export type MaterialRequestScalarWhereWithAggregatesInput = {
    AND?: MaterialRequestScalarWhereWithAggregatesInput | MaterialRequestScalarWhereWithAggregatesInput[]
    OR?: MaterialRequestScalarWhereWithAggregatesInput[]
    NOT?: MaterialRequestScalarWhereWithAggregatesInput | MaterialRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaterialRequest"> | string
    materialId?: StringWithAggregatesFilter<"MaterialRequest"> | string
    projectId?: StringWithAggregatesFilter<"MaterialRequest"> | string
    crewId?: StringWithAggregatesFilter<"MaterialRequest"> | string
    cantidad?: IntWithAggregatesFilter<"MaterialRequest"> | number
    estado?: EnumMaterialRequestStateWithAggregatesFilter<"MaterialRequest"> | $Enums.MaterialRequestState
    createdAt?: DateTimeWithAggregatesFilter<"MaterialRequest"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    conversationId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    conversationId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    receiverId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type CommunicationRequestWhereInput = {
    AND?: CommunicationRequestWhereInput | CommunicationRequestWhereInput[]
    OR?: CommunicationRequestWhereInput[]
    NOT?: CommunicationRequestWhereInput | CommunicationRequestWhereInput[]
    id?: StringFilter<"CommunicationRequest"> | string
    senderId?: StringFilter<"CommunicationRequest"> | string
    requestType?: EnumRequestTypeFilter<"CommunicationRequest"> | $Enums.RequestType
    description?: StringFilter<"CommunicationRequest"> | string
    urgency?: StringFilter<"CommunicationRequest"> | string
    crewId?: StringFilter<"CommunicationRequest"> | string
    estado?: EnumRequestStatusFilter<"CommunicationRequest"> | $Enums.RequestStatus
    respuesta?: StringNullableFilter<"CommunicationRequest"> | string | null
    createdAt?: DateTimeFilter<"CommunicationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CommunicationRequest"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }

  export type CommunicationRequestOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    requestType?: SortOrder
    description?: SortOrder
    urgency?: SortOrder
    crewId?: SortOrder
    estado?: SortOrder
    respuesta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    crew?: CrewOrderByWithRelationInput
  }

  export type CommunicationRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunicationRequestWhereInput | CommunicationRequestWhereInput[]
    OR?: CommunicationRequestWhereInput[]
    NOT?: CommunicationRequestWhereInput | CommunicationRequestWhereInput[]
    senderId?: StringFilter<"CommunicationRequest"> | string
    requestType?: EnumRequestTypeFilter<"CommunicationRequest"> | $Enums.RequestType
    description?: StringFilter<"CommunicationRequest"> | string
    urgency?: StringFilter<"CommunicationRequest"> | string
    crewId?: StringFilter<"CommunicationRequest"> | string
    estado?: EnumRequestStatusFilter<"CommunicationRequest"> | $Enums.RequestStatus
    respuesta?: StringNullableFilter<"CommunicationRequest"> | string | null
    createdAt?: DateTimeFilter<"CommunicationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CommunicationRequest"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }, "id">

  export type CommunicationRequestOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    requestType?: SortOrder
    description?: SortOrder
    urgency?: SortOrder
    crewId?: SortOrder
    estado?: SortOrder
    respuesta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunicationRequestCountOrderByAggregateInput
    _max?: CommunicationRequestMaxOrderByAggregateInput
    _min?: CommunicationRequestMinOrderByAggregateInput
  }

  export type CommunicationRequestScalarWhereWithAggregatesInput = {
    AND?: CommunicationRequestScalarWhereWithAggregatesInput | CommunicationRequestScalarWhereWithAggregatesInput[]
    OR?: CommunicationRequestScalarWhereWithAggregatesInput[]
    NOT?: CommunicationRequestScalarWhereWithAggregatesInput | CommunicationRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunicationRequest"> | string
    senderId?: StringWithAggregatesFilter<"CommunicationRequest"> | string
    requestType?: EnumRequestTypeWithAggregatesFilter<"CommunicationRequest"> | $Enums.RequestType
    description?: StringWithAggregatesFilter<"CommunicationRequest"> | string
    urgency?: StringWithAggregatesFilter<"CommunicationRequest"> | string
    crewId?: StringWithAggregatesFilter<"CommunicationRequest"> | string
    estado?: EnumRequestStatusWithAggregatesFilter<"CommunicationRequest"> | $Enums.RequestStatus
    respuesta?: StringNullableWithAggregatesFilter<"CommunicationRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CommunicationRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommunicationRequest"> | Date | string
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: StringFilter<"Certificate"> | string
    name?: StringFilter<"Certificate"> | string
    description?: StringNullableFilter<"Certificate"> | string | null
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    workers?: WorkerListRelationFilter
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    workers?: WorkerOrderByRelationAggregateInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    name?: StringFilter<"Certificate"> | string
    description?: StringNullableFilter<"Certificate"> | string | null
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    workers?: WorkerListRelationFilter
  }, "id">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certificate"> | string
    name?: StringWithAggregatesFilter<"Certificate"> | string
    description?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: StringFilter<"Milestone"> | string
    projectId?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    targetDate?: DateTimeFilter<"Milestone"> | Date | string
    estado?: StringFilter<"Milestone"> | string
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    targetDate?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    projectId?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    targetDate?: DateTimeFilter<"Milestone"> | Date | string
    estado?: StringFilter<"Milestone"> | string
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    targetDate?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Milestone"> | string
    projectId?: StringWithAggregatesFilter<"Milestone"> | string
    title?: StringWithAggregatesFilter<"Milestone"> | string
    description?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    targetDate?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    estado?: StringWithAggregatesFilter<"Milestone"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    crewId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    prioridad?: StringFilter<"Task"> | string
    estado?: StringFilter<"Task"> | string
    fecha_vencimiento?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    crewId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    fecha_vencimiento?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    crew?: CrewOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    crewId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    prioridad?: StringFilter<"Task"> | string
    estado?: StringFilter<"Task"> | string
    fecha_vencimiento?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    crewId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    fecha_vencimiento?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    crewId?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    prioridad?: StringWithAggregatesFilter<"Task"> | string
    estado?: StringWithAggregatesFilter<"Task"> | string
    fecha_vencimiento?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    projectId?: StringNullableFilter<"AuditLog"> | string | null
    changes?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    projectId?: StringNullableFilter<"AuditLog"> | string | null
    changes?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    changes?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutJefeInput
    logs?: LogCreateNestedManyWithoutResponsableInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    requests?: CommunicationRequestCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutJefeInput
    logs?: LogUncheckedCreateNestedManyWithoutResponsableInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    requests?: CommunicationRequestUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutJefeNestedInput
    logs?: LogUpdateManyWithoutResponsableNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    requests?: CommunicationRequestUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutJefeNestedInput
    logs?: LogUncheckedUpdateManyWithoutResponsableNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    requests?: CommunicationRequestUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefe?: UserCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefeId?: string | null
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefe?: UserUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefeId?: NullableStringFieldUpdateOperationsInput | string | null
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefeId?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerCreateInput = {
    id?: string
    name: string
    rut?: string | null
    especialidad: string
    certificaciones?: string | null
    experiencia?: number | null
    disponibilidad?: boolean
    estado: string
    zona_preferencia?: string | null
    crewWorkers?: CrewWorkerCreateNestedManyWithoutWorkerInput
    certificates?: CertificateCreateNestedManyWithoutWorkersInput
  }

  export type WorkerUncheckedCreateInput = {
    id?: string
    name: string
    rut?: string | null
    especialidad: string
    certificaciones?: string | null
    experiencia?: number | null
    disponibilidad?: boolean
    estado: string
    zona_preferencia?: string | null
    crewWorkers?: CrewWorkerUncheckedCreateNestedManyWithoutWorkerInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutWorkersInput
  }

  export type WorkerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rut?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    certificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableIntFieldUpdateOperationsInput | number | null
    disponibilidad?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    zona_preferencia?: NullableStringFieldUpdateOperationsInput | string | null
    crewWorkers?: CrewWorkerUpdateManyWithoutWorkerNestedInput
    certificates?: CertificateUpdateManyWithoutWorkersNestedInput
  }

  export type WorkerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rut?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    certificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableIntFieldUpdateOperationsInput | number | null
    disponibilidad?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    zona_preferencia?: NullableStringFieldUpdateOperationsInput | string | null
    crewWorkers?: CrewWorkerUncheckedUpdateManyWithoutWorkerNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutWorkersNestedInput
  }

  export type WorkerCreateManyInput = {
    id?: string
    name: string
    rut?: string | null
    especialidad: string
    certificaciones?: string | null
    experiencia?: number | null
    disponibilidad?: boolean
    estado: string
    zona_preferencia?: string | null
  }

  export type WorkerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rut?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    certificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableIntFieldUpdateOperationsInput | number | null
    disponibilidad?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    zona_preferencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rut?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    certificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableIntFieldUpdateOperationsInput | number | null
    disponibilidad?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    zona_preferencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrewCreateInput = {
    id?: string
    name: string
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    project?: ProjectCreateNestedOneWithoutCrewsInput
    crewWorkers?: CrewWorkerCreateNestedManyWithoutCrewInput
    logs?: LogCreateNestedManyWithoutCrewInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutCrewInput
    communicationRequests?: CommunicationRequestCreateNestedManyWithoutCrewInput
    tasks?: TaskCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateInput = {
    id?: string
    name: string
    projectId?: string | null
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    crewWorkers?: CrewWorkerUncheckedCreateNestedManyWithoutCrewInput
    logs?: LogUncheckedCreateNestedManyWithoutCrewInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutCrewInput
    communicationRequests?: CommunicationRequestUncheckedCreateNestedManyWithoutCrewInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    project?: ProjectUpdateOneWithoutCrewsNestedInput
    crewWorkers?: CrewWorkerUpdateManyWithoutCrewNestedInput
    logs?: LogUpdateManyWithoutCrewNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutCrewNestedInput
    communicationRequests?: CommunicationRequestUpdateManyWithoutCrewNestedInput
    tasks?: TaskUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    crewWorkers?: CrewWorkerUncheckedUpdateManyWithoutCrewNestedInput
    logs?: LogUncheckedUpdateManyWithoutCrewNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutCrewNestedInput
    communicationRequests?: CommunicationRequestUncheckedUpdateManyWithoutCrewNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewCreateManyInput = {
    id?: string
    name: string
    projectId?: string | null
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
  }

  export type CrewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CrewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CrewWorkerCreateInput = {
    id?: string
    role: string
    fecha_asignacion?: Date | string
    crew: CrewCreateNestedOneWithoutCrewWorkersInput
    worker: WorkerCreateNestedOneWithoutCrewWorkersInput
  }

  export type CrewWorkerUncheckedCreateInput = {
    id?: string
    crewId: string
    workerId: string
    role: string
    fecha_asignacion?: Date | string
  }

  export type CrewWorkerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    fecha_asignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    crew?: CrewUpdateOneRequiredWithoutCrewWorkersNestedInput
    worker?: WorkerUpdateOneRequiredWithoutCrewWorkersNestedInput
  }

  export type CrewWorkerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    fecha_asignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewWorkerCreateManyInput = {
    id?: string
    crewId: string
    workerId: string
    role: string
    fecha_asignacion?: Date | string
  }

  export type CrewWorkerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    fecha_asignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewWorkerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    fecha_asignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateInput = {
    id?: string
    descripcion?: string | null
    incidentes?: string | null
    consumo_materiales?: string | null
    avance?: string | null
    fecha?: Date | string
    actividades?: string | null
    materiales_consumidos?: string | null
    tiempos_trabajo?: string | null
    observaciones?: string | null
    estado_herramientas?: string | null
    crew: CrewCreateNestedOneWithoutLogsInput
    project: ProjectCreateNestedOneWithoutLogsInput
    responsable: UserCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: string
    crewId: string
    projectId: string
    descripcion?: string | null
    incidentes?: string | null
    consumo_materiales?: string | null
    avance?: string | null
    fecha?: Date | string
    responsableId: string
    actividades?: string | null
    materiales_consumidos?: string | null
    tiempos_trabajo?: string | null
    observaciones?: string | null
    estado_herramientas?: string | null
  }

  export type LogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
    crew?: CrewUpdateOneRequiredWithoutLogsNestedInput
    project?: ProjectUpdateOneRequiredWithoutLogsNestedInput
    responsable?: UserUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    responsableId?: StringFieldUpdateOperationsInput | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogCreateManyInput = {
    id?: string
    crewId: string
    projectId: string
    descripcion?: string | null
    incidentes?: string | null
    consumo_materiales?: string | null
    avance?: string | null
    fecha?: Date | string
    responsableId: string
    actividades?: string | null
    materiales_consumidos?: string | null
    tiempos_trabajo?: string | null
    observaciones?: string | null
    estado_herramientas?: string | null
  }

  export type LogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    responsableId?: StringFieldUpdateOperationsInput | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialCreateInput = {
    id?: string
    name: string
    descripcion?: string | null
    stock: number
    unidad: string
    precio: number
    requests?: MaterialRequestCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: string
    name: string
    descripcion?: string | null
    stock: number
    unidad: string
    precio: number
    requests?: MaterialRequestUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    unidad?: StringFieldUpdateOperationsInput | string
    precio?: FloatFieldUpdateOperationsInput | number
    requests?: MaterialRequestUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    unidad?: StringFieldUpdateOperationsInput | string
    precio?: FloatFieldUpdateOperationsInput | number
    requests?: MaterialRequestUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialCreateManyInput = {
    id?: string
    name: string
    descripcion?: string | null
    stock: number
    unidad: string
    precio: number
  }

  export type MaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    unidad?: StringFieldUpdateOperationsInput | string
    precio?: FloatFieldUpdateOperationsInput | number
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    unidad?: StringFieldUpdateOperationsInput | string
    precio?: FloatFieldUpdateOperationsInput | number
  }

  export type MaterialRequestCreateInput = {
    id?: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt?: Date | string
    material: MaterialCreateNestedOneWithoutRequestsInput
    project: ProjectCreateNestedOneWithoutMaterialRequestsInput
    crew: CrewCreateNestedOneWithoutMaterialRequestsInput
  }

  export type MaterialRequestUncheckedCreateInput = {
    id?: string
    materialId: string
    projectId: string
    crewId: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt?: Date | string
  }

  export type MaterialRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutRequestsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMaterialRequestsNestedInput
    crew?: CrewUpdateOneRequiredWithoutMaterialRequestsNestedInput
  }

  export type MaterialRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestCreateManyInput = {
    id?: string
    materialId: string
    projectId: string
    crewId: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt?: Date | string
  }

  export type MaterialRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    conversationId?: string | null
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    conversationId?: string | null
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    conversationId?: string | null
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationRequestCreateInput = {
    id?: string
    requestType: $Enums.RequestType
    description: string
    urgency?: string
    estado?: $Enums.RequestStatus
    respuesta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutRequestsInput
    crew: CrewCreateNestedOneWithoutCommunicationRequestsInput
  }

  export type CommunicationRequestUncheckedCreateInput = {
    id?: string
    senderId: string
    requestType: $Enums.RequestType
    description: string
    urgency?: string
    crewId: string
    estado?: $Enums.RequestStatus
    respuesta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    description?: StringFieldUpdateOperationsInput | string
    urgency?: StringFieldUpdateOperationsInput | string
    estado?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutRequestsNestedInput
    crew?: CrewUpdateOneRequiredWithoutCommunicationRequestsNestedInput
  }

  export type CommunicationRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    description?: StringFieldUpdateOperationsInput | string
    urgency?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    estado?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationRequestCreateManyInput = {
    id?: string
    senderId: string
    requestType: $Enums.RequestType
    description: string
    urgency?: string
    crewId: string
    estado?: $Enums.RequestStatus
    respuesta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    description?: StringFieldUpdateOperationsInput | string
    urgency?: StringFieldUpdateOperationsInput | string
    estado?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    description?: StringFieldUpdateOperationsInput | string
    urgency?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    estado?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    workers?: WorkerCreateNestedManyWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    workers?: WorkerUncheckedCreateNestedManyWithoutCertificatesInput
  }

  export type CertificateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workers?: WorkerUpdateManyWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workers?: WorkerUncheckedUpdateManyWithoutCertificatesNestedInput
  }

  export type CertificateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type CertificateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateInput = {
    id?: string
    title: string
    description?: string | null
    targetDate: Date | string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMilestonesInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    targetDate: Date | string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateManyInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    targetDate: Date | string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    prioridad?: string
    estado?: string
    fecha_vencimiento?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    crew: CrewCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    crewId: string
    title: string
    description?: string | null
    prioridad?: string
    estado?: string
    fecha_vencimiento?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crew?: CrewUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    crewId: string
    title: string
    description?: string | null
    prioridad?: string
    estado?: string
    fecha_vencimiento?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId?: string | null
    changes?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    project?: ProjectCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId?: string | null
    projectId?: string | null
    changes?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId?: string | null
    projectId?: string | null
    changes?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type CommunicationRequestListRelationFilter = {
    every?: CommunicationRequestWhereInput
    some?: CommunicationRequestWhereInput
    none?: CommunicationRequestWhereInput
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunicationRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CrewListRelationFilter = {
    every?: CrewWhereInput
    some?: CrewWhereInput
    none?: CrewWhereInput
  }

  export type MaterialRequestListRelationFilter = {
    every?: MaterialRequestWhereInput
    some?: MaterialRequestWhereInput
    none?: MaterialRequestWhereInput
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CrewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tipo_obra?: SortOrder
    complejidad?: SortOrder
    duracion_estimada?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
    zona_trabajo?: SortOrder
    estado?: SortOrder
    presupuesto?: SortOrder
    supervisor?: SortOrder
    descripcion_tecnica?: SortOrder
    jefeId?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    duracion_estimada?: SortOrder
    presupuesto?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tipo_obra?: SortOrder
    complejidad?: SortOrder
    duracion_estimada?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
    zona_trabajo?: SortOrder
    estado?: SortOrder
    presupuesto?: SortOrder
    supervisor?: SortOrder
    descripcion_tecnica?: SortOrder
    jefeId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tipo_obra?: SortOrder
    complejidad?: SortOrder
    duracion_estimada?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
    zona_trabajo?: SortOrder
    estado?: SortOrder
    presupuesto?: SortOrder
    supervisor?: SortOrder
    descripcion_tecnica?: SortOrder
    jefeId?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    duracion_estimada?: SortOrder
    presupuesto?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CrewWorkerListRelationFilter = {
    every?: CrewWorkerWhereInput
    some?: CrewWorkerWhereInput
    none?: CrewWorkerWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type CrewWorkerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rut?: SortOrder
    especialidad?: SortOrder
    certificaciones?: SortOrder
    experiencia?: SortOrder
    disponibilidad?: SortOrder
    estado?: SortOrder
    zona_preferencia?: SortOrder
  }

  export type WorkerAvgOrderByAggregateInput = {
    experiencia?: SortOrder
  }

  export type WorkerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rut?: SortOrder
    especialidad?: SortOrder
    certificaciones?: SortOrder
    experiencia?: SortOrder
    disponibilidad?: SortOrder
    estado?: SortOrder
    zona_preferencia?: SortOrder
  }

  export type WorkerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rut?: SortOrder
    especialidad?: SortOrder
    certificaciones?: SortOrder
    experiencia?: SortOrder
    disponibilidad?: SortOrder
    estado?: SortOrder
    zona_preferencia?: SortOrder
  }

  export type WorkerSumOrderByAggregateInput = {
    experiencia?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumCrewStateFilter<$PrismaModel = never> = {
    equals?: $Enums.CrewState | EnumCrewStateFieldRefInput<$PrismaModel>
    in?: $Enums.CrewState[] | ListEnumCrewStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrewState[] | ListEnumCrewStateFieldRefInput<$PrismaModel>
    not?: NestedEnumCrewStateFilter<$PrismaModel> | $Enums.CrewState
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    fecha_inicio?: SortOrder
    estado?: SortOrder
    zona_trabajo?: SortOrder
    fecha_plazo?: SortOrder
    cantidad_trabajadores?: SortOrder
  }

  export type CrewAvgOrderByAggregateInput = {
    cantidad_trabajadores?: SortOrder
  }

  export type CrewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    fecha_inicio?: SortOrder
    estado?: SortOrder
    zona_trabajo?: SortOrder
    fecha_plazo?: SortOrder
    cantidad_trabajadores?: SortOrder
  }

  export type CrewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    fecha_inicio?: SortOrder
    estado?: SortOrder
    zona_trabajo?: SortOrder
    fecha_plazo?: SortOrder
    cantidad_trabajadores?: SortOrder
  }

  export type CrewSumOrderByAggregateInput = {
    cantidad_trabajadores?: SortOrder
  }

  export type EnumCrewStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CrewState | EnumCrewStateFieldRefInput<$PrismaModel>
    in?: $Enums.CrewState[] | ListEnumCrewStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrewState[] | ListEnumCrewStateFieldRefInput<$PrismaModel>
    not?: NestedEnumCrewStateWithAggregatesFilter<$PrismaModel> | $Enums.CrewState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCrewStateFilter<$PrismaModel>
    _max?: NestedEnumCrewStateFilter<$PrismaModel>
  }

  export type CrewRelationFilter = {
    is?: CrewWhereInput
    isNot?: CrewWhereInput
  }

  export type WorkerRelationFilter = {
    is?: WorkerWhereInput
    isNot?: WorkerWhereInput
  }

  export type CrewWorkerCountOrderByAggregateInput = {
    id?: SortOrder
    crewId?: SortOrder
    workerId?: SortOrder
    role?: SortOrder
    fecha_asignacion?: SortOrder
  }

  export type CrewWorkerMaxOrderByAggregateInput = {
    id?: SortOrder
    crewId?: SortOrder
    workerId?: SortOrder
    role?: SortOrder
    fecha_asignacion?: SortOrder
  }

  export type CrewWorkerMinOrderByAggregateInput = {
    id?: SortOrder
    crewId?: SortOrder
    workerId?: SortOrder
    role?: SortOrder
    fecha_asignacion?: SortOrder
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    crewId?: SortOrder
    projectId?: SortOrder
    descripcion?: SortOrder
    incidentes?: SortOrder
    consumo_materiales?: SortOrder
    avance?: SortOrder
    fecha?: SortOrder
    responsableId?: SortOrder
    actividades?: SortOrder
    materiales_consumidos?: SortOrder
    tiempos_trabajo?: SortOrder
    observaciones?: SortOrder
    estado_herramientas?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    crewId?: SortOrder
    projectId?: SortOrder
    descripcion?: SortOrder
    incidentes?: SortOrder
    consumo_materiales?: SortOrder
    avance?: SortOrder
    fecha?: SortOrder
    responsableId?: SortOrder
    actividades?: SortOrder
    materiales_consumidos?: SortOrder
    tiempos_trabajo?: SortOrder
    observaciones?: SortOrder
    estado_herramientas?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    crewId?: SortOrder
    projectId?: SortOrder
    descripcion?: SortOrder
    incidentes?: SortOrder
    consumo_materiales?: SortOrder
    avance?: SortOrder
    fecha?: SortOrder
    responsableId?: SortOrder
    actividades?: SortOrder
    materiales_consumidos?: SortOrder
    tiempos_trabajo?: SortOrder
    observaciones?: SortOrder
    estado_herramientas?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    descripcion?: SortOrder
    stock?: SortOrder
    unidad?: SortOrder
    precio?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    stock?: SortOrder
    precio?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    descripcion?: SortOrder
    stock?: SortOrder
    unidad?: SortOrder
    precio?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    descripcion?: SortOrder
    stock?: SortOrder
    unidad?: SortOrder
    precio?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    stock?: SortOrder
    precio?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumMaterialRequestStateFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialRequestState | EnumMaterialRequestStateFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialRequestState[] | ListEnumMaterialRequestStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialRequestState[] | ListEnumMaterialRequestStateFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialRequestStateFilter<$PrismaModel> | $Enums.MaterialRequestState
  }

  export type MaterialRelationFilter = {
    is?: MaterialWhereInput
    isNot?: MaterialWhereInput
  }

  export type MaterialRequestCountOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    projectId?: SortOrder
    crewId?: SortOrder
    cantidad?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
  }

  export type MaterialRequestAvgOrderByAggregateInput = {
    cantidad?: SortOrder
  }

  export type MaterialRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    projectId?: SortOrder
    crewId?: SortOrder
    cantidad?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
  }

  export type MaterialRequestMinOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    projectId?: SortOrder
    crewId?: SortOrder
    cantidad?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
  }

  export type MaterialRequestSumOrderByAggregateInput = {
    cantidad?: SortOrder
  }

  export type EnumMaterialRequestStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialRequestState | EnumMaterialRequestStateFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialRequestState[] | ListEnumMaterialRequestStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialRequestState[] | ListEnumMaterialRequestStateFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialRequestStateWithAggregatesFilter<$PrismaModel> | $Enums.MaterialRequestState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialRequestStateFilter<$PrismaModel>
    _max?: NestedEnumMaterialRequestStateFilter<$PrismaModel>
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    conversationId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    conversationId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    conversationId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRequestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestType | EnumRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestTypeFilter<$PrismaModel> | $Enums.RequestType
  }

  export type EnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type CommunicationRequestCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    requestType?: SortOrder
    description?: SortOrder
    urgency?: SortOrder
    crewId?: SortOrder
    estado?: SortOrder
    respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunicationRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    requestType?: SortOrder
    description?: SortOrder
    urgency?: SortOrder
    crewId?: SortOrder
    estado?: SortOrder
    respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunicationRequestMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    requestType?: SortOrder
    description?: SortOrder
    urgency?: SortOrder
    crewId?: SortOrder
    estado?: SortOrder
    respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRequestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestType | EnumRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestTypeWithAggregatesFilter<$PrismaModel> | $Enums.RequestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestTypeFilter<$PrismaModel>
    _max?: NestedEnumRequestTypeFilter<$PrismaModel>
  }

  export type EnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type WorkerListRelationFilter = {
    every?: WorkerWhereInput
    some?: WorkerWhereInput
    none?: WorkerWhereInput
  }

  export type WorkerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    targetDate?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    targetDate?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    targetDate?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    crewId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    fecha_vencimiento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    crewId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    fecha_vencimiento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    crewId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    fecha_vencimiento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    projectId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    projectId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    projectId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectCreateNestedManyWithoutJefeInput = {
    create?: XOR<ProjectCreateWithoutJefeInput, ProjectUncheckedCreateWithoutJefeInput> | ProjectCreateWithoutJefeInput[] | ProjectUncheckedCreateWithoutJefeInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutJefeInput | ProjectCreateOrConnectWithoutJefeInput[]
    createMany?: ProjectCreateManyJefeInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutResponsableInput = {
    create?: XOR<LogCreateWithoutResponsableInput, LogUncheckedCreateWithoutResponsableInput> | LogCreateWithoutResponsableInput[] | LogUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: LogCreateOrConnectWithoutResponsableInput | LogCreateOrConnectWithoutResponsableInput[]
    createMany?: LogCreateManyResponsableInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type CommunicationRequestCreateNestedManyWithoutSenderInput = {
    create?: XOR<CommunicationRequestCreateWithoutSenderInput, CommunicationRequestUncheckedCreateWithoutSenderInput> | CommunicationRequestCreateWithoutSenderInput[] | CommunicationRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: CommunicationRequestCreateOrConnectWithoutSenderInput | CommunicationRequestCreateOrConnectWithoutSenderInput[]
    createMany?: CommunicationRequestCreateManySenderInputEnvelope
    connect?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutJefeInput = {
    create?: XOR<ProjectCreateWithoutJefeInput, ProjectUncheckedCreateWithoutJefeInput> | ProjectCreateWithoutJefeInput[] | ProjectUncheckedCreateWithoutJefeInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutJefeInput | ProjectCreateOrConnectWithoutJefeInput[]
    createMany?: ProjectCreateManyJefeInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutResponsableInput = {
    create?: XOR<LogCreateWithoutResponsableInput, LogUncheckedCreateWithoutResponsableInput> | LogCreateWithoutResponsableInput[] | LogUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: LogCreateOrConnectWithoutResponsableInput | LogCreateOrConnectWithoutResponsableInput[]
    createMany?: LogCreateManyResponsableInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type CommunicationRequestUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<CommunicationRequestCreateWithoutSenderInput, CommunicationRequestUncheckedCreateWithoutSenderInput> | CommunicationRequestCreateWithoutSenderInput[] | CommunicationRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: CommunicationRequestCreateOrConnectWithoutSenderInput | CommunicationRequestCreateOrConnectWithoutSenderInput[]
    createMany?: CommunicationRequestCreateManySenderInputEnvelope
    connect?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProjectUpdateManyWithoutJefeNestedInput = {
    create?: XOR<ProjectCreateWithoutJefeInput, ProjectUncheckedCreateWithoutJefeInput> | ProjectCreateWithoutJefeInput[] | ProjectUncheckedCreateWithoutJefeInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutJefeInput | ProjectCreateOrConnectWithoutJefeInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutJefeInput | ProjectUpsertWithWhereUniqueWithoutJefeInput[]
    createMany?: ProjectCreateManyJefeInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutJefeInput | ProjectUpdateWithWhereUniqueWithoutJefeInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutJefeInput | ProjectUpdateManyWithWhereWithoutJefeInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type LogUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<LogCreateWithoutResponsableInput, LogUncheckedCreateWithoutResponsableInput> | LogCreateWithoutResponsableInput[] | LogUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: LogCreateOrConnectWithoutResponsableInput | LogCreateOrConnectWithoutResponsableInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutResponsableInput | LogUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: LogCreateManyResponsableInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutResponsableInput | LogUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: LogUpdateManyWithWhereWithoutResponsableInput | LogUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type CommunicationRequestUpdateManyWithoutSenderNestedInput = {
    create?: XOR<CommunicationRequestCreateWithoutSenderInput, CommunicationRequestUncheckedCreateWithoutSenderInput> | CommunicationRequestCreateWithoutSenderInput[] | CommunicationRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: CommunicationRequestCreateOrConnectWithoutSenderInput | CommunicationRequestCreateOrConnectWithoutSenderInput[]
    upsert?: CommunicationRequestUpsertWithWhereUniqueWithoutSenderInput | CommunicationRequestUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: CommunicationRequestCreateManySenderInputEnvelope
    set?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    disconnect?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    delete?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    connect?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    update?: CommunicationRequestUpdateWithWhereUniqueWithoutSenderInput | CommunicationRequestUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: CommunicationRequestUpdateManyWithWhereWithoutSenderInput | CommunicationRequestUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: CommunicationRequestScalarWhereInput | CommunicationRequestScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutJefeNestedInput = {
    create?: XOR<ProjectCreateWithoutJefeInput, ProjectUncheckedCreateWithoutJefeInput> | ProjectCreateWithoutJefeInput[] | ProjectUncheckedCreateWithoutJefeInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutJefeInput | ProjectCreateOrConnectWithoutJefeInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutJefeInput | ProjectUpsertWithWhereUniqueWithoutJefeInput[]
    createMany?: ProjectCreateManyJefeInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutJefeInput | ProjectUpdateWithWhereUniqueWithoutJefeInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutJefeInput | ProjectUpdateManyWithWhereWithoutJefeInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<LogCreateWithoutResponsableInput, LogUncheckedCreateWithoutResponsableInput> | LogCreateWithoutResponsableInput[] | LogUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: LogCreateOrConnectWithoutResponsableInput | LogCreateOrConnectWithoutResponsableInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutResponsableInput | LogUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: LogCreateManyResponsableInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutResponsableInput | LogUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: LogUpdateManyWithWhereWithoutResponsableInput | LogUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type CommunicationRequestUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<CommunicationRequestCreateWithoutSenderInput, CommunicationRequestUncheckedCreateWithoutSenderInput> | CommunicationRequestCreateWithoutSenderInput[] | CommunicationRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: CommunicationRequestCreateOrConnectWithoutSenderInput | CommunicationRequestCreateOrConnectWithoutSenderInput[]
    upsert?: CommunicationRequestUpsertWithWhereUniqueWithoutSenderInput | CommunicationRequestUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: CommunicationRequestCreateManySenderInputEnvelope
    set?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    disconnect?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    delete?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    connect?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    update?: CommunicationRequestUpdateWithWhereUniqueWithoutSenderInput | CommunicationRequestUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: CommunicationRequestUpdateManyWithWhereWithoutSenderInput | CommunicationRequestUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: CommunicationRequestScalarWhereInput | CommunicationRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type CrewCreateNestedManyWithoutProjectInput = {
    create?: XOR<CrewCreateWithoutProjectInput, CrewUncheckedCreateWithoutProjectInput> | CrewCreateWithoutProjectInput[] | CrewUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutProjectInput | CrewCreateOrConnectWithoutProjectInput[]
    createMany?: CrewCreateManyProjectInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type MaterialRequestCreateNestedManyWithoutProjectInput = {
    create?: XOR<MaterialRequestCreateWithoutProjectInput, MaterialRequestUncheckedCreateWithoutProjectInput> | MaterialRequestCreateWithoutProjectInput[] | MaterialRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutProjectInput | MaterialRequestCreateOrConnectWithoutProjectInput[]
    createMany?: MaterialRequestCreateManyProjectInputEnvelope
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutProjectInput = {
    create?: XOR<LogCreateWithoutProjectInput, LogUncheckedCreateWithoutProjectInput> | LogCreateWithoutProjectInput[] | LogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LogCreateOrConnectWithoutProjectInput | LogCreateOrConnectWithoutProjectInput[]
    createMany?: LogCreateManyProjectInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type MilestoneCreateNestedManyWithoutProjectInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutProjectInput = {
    create?: XOR<AuditLogCreateWithoutProjectInput, AuditLogUncheckedCreateWithoutProjectInput> | AuditLogCreateWithoutProjectInput[] | AuditLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutProjectInput | AuditLogCreateOrConnectWithoutProjectInput[]
    createMany?: AuditLogCreateManyProjectInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CrewUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CrewCreateWithoutProjectInput, CrewUncheckedCreateWithoutProjectInput> | CrewCreateWithoutProjectInput[] | CrewUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutProjectInput | CrewCreateOrConnectWithoutProjectInput[]
    createMany?: CrewCreateManyProjectInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type MaterialRequestUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MaterialRequestCreateWithoutProjectInput, MaterialRequestUncheckedCreateWithoutProjectInput> | MaterialRequestCreateWithoutProjectInput[] | MaterialRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutProjectInput | MaterialRequestCreateOrConnectWithoutProjectInput[]
    createMany?: MaterialRequestCreateManyProjectInputEnvelope
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<LogCreateWithoutProjectInput, LogUncheckedCreateWithoutProjectInput> | LogCreateWithoutProjectInput[] | LogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LogCreateOrConnectWithoutProjectInput | LogCreateOrConnectWithoutProjectInput[]
    createMany?: LogCreateManyProjectInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type MilestoneUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AuditLogCreateWithoutProjectInput, AuditLogUncheckedCreateWithoutProjectInput> | AuditLogCreateWithoutProjectInput[] | AuditLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutProjectInput | AuditLogCreateOrConnectWithoutProjectInput[]
    createMany?: AuditLogCreateManyProjectInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type CrewUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CrewCreateWithoutProjectInput, CrewUncheckedCreateWithoutProjectInput> | CrewCreateWithoutProjectInput[] | CrewUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutProjectInput | CrewCreateOrConnectWithoutProjectInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutProjectInput | CrewUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CrewCreateManyProjectInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutProjectInput | CrewUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutProjectInput | CrewUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type MaterialRequestUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutProjectInput, MaterialRequestUncheckedCreateWithoutProjectInput> | MaterialRequestCreateWithoutProjectInput[] | MaterialRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutProjectInput | MaterialRequestCreateOrConnectWithoutProjectInput[]
    upsert?: MaterialRequestUpsertWithWhereUniqueWithoutProjectInput | MaterialRequestUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MaterialRequestCreateManyProjectInputEnvelope
    set?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    disconnect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    delete?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    update?: MaterialRequestUpdateWithWhereUniqueWithoutProjectInput | MaterialRequestUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MaterialRequestUpdateManyWithWhereWithoutProjectInput | MaterialRequestUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
  }

  export type LogUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LogCreateWithoutProjectInput, LogUncheckedCreateWithoutProjectInput> | LogCreateWithoutProjectInput[] | LogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LogCreateOrConnectWithoutProjectInput | LogCreateOrConnectWithoutProjectInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutProjectInput | LogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LogCreateManyProjectInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutProjectInput | LogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LogUpdateManyWithWhereWithoutProjectInput | LogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type MilestoneUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutProjectInput | MilestoneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutProjectInput | MilestoneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutProjectInput | MilestoneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AuditLogCreateWithoutProjectInput, AuditLogUncheckedCreateWithoutProjectInput> | AuditLogCreateWithoutProjectInput[] | AuditLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutProjectInput | AuditLogCreateOrConnectWithoutProjectInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutProjectInput | AuditLogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AuditLogCreateManyProjectInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutProjectInput | AuditLogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutProjectInput | AuditLogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CrewUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CrewCreateWithoutProjectInput, CrewUncheckedCreateWithoutProjectInput> | CrewCreateWithoutProjectInput[] | CrewUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutProjectInput | CrewCreateOrConnectWithoutProjectInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutProjectInput | CrewUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CrewCreateManyProjectInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutProjectInput | CrewUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutProjectInput | CrewUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutProjectInput, MaterialRequestUncheckedCreateWithoutProjectInput> | MaterialRequestCreateWithoutProjectInput[] | MaterialRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutProjectInput | MaterialRequestCreateOrConnectWithoutProjectInput[]
    upsert?: MaterialRequestUpsertWithWhereUniqueWithoutProjectInput | MaterialRequestUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MaterialRequestCreateManyProjectInputEnvelope
    set?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    disconnect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    delete?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    update?: MaterialRequestUpdateWithWhereUniqueWithoutProjectInput | MaterialRequestUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MaterialRequestUpdateManyWithWhereWithoutProjectInput | MaterialRequestUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LogCreateWithoutProjectInput, LogUncheckedCreateWithoutProjectInput> | LogCreateWithoutProjectInput[] | LogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LogCreateOrConnectWithoutProjectInput | LogCreateOrConnectWithoutProjectInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutProjectInput | LogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LogCreateManyProjectInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutProjectInput | LogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LogUpdateManyWithWhereWithoutProjectInput | LogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type MilestoneUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutProjectInput | MilestoneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutProjectInput | MilestoneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutProjectInput | MilestoneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AuditLogCreateWithoutProjectInput, AuditLogUncheckedCreateWithoutProjectInput> | AuditLogCreateWithoutProjectInput[] | AuditLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutProjectInput | AuditLogCreateOrConnectWithoutProjectInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutProjectInput | AuditLogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AuditLogCreateManyProjectInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutProjectInput | AuditLogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutProjectInput | AuditLogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CrewWorkerCreateNestedManyWithoutWorkerInput = {
    create?: XOR<CrewWorkerCreateWithoutWorkerInput, CrewWorkerUncheckedCreateWithoutWorkerInput> | CrewWorkerCreateWithoutWorkerInput[] | CrewWorkerUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: CrewWorkerCreateOrConnectWithoutWorkerInput | CrewWorkerCreateOrConnectWithoutWorkerInput[]
    createMany?: CrewWorkerCreateManyWorkerInputEnvelope
    connect?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutWorkersInput = {
    create?: XOR<CertificateCreateWithoutWorkersInput, CertificateUncheckedCreateWithoutWorkersInput> | CertificateCreateWithoutWorkersInput[] | CertificateUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutWorkersInput | CertificateCreateOrConnectWithoutWorkersInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type CrewWorkerUncheckedCreateNestedManyWithoutWorkerInput = {
    create?: XOR<CrewWorkerCreateWithoutWorkerInput, CrewWorkerUncheckedCreateWithoutWorkerInput> | CrewWorkerCreateWithoutWorkerInput[] | CrewWorkerUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: CrewWorkerCreateOrConnectWithoutWorkerInput | CrewWorkerCreateOrConnectWithoutWorkerInput[]
    createMany?: CrewWorkerCreateManyWorkerInputEnvelope
    connect?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutWorkersInput = {
    create?: XOR<CertificateCreateWithoutWorkersInput, CertificateUncheckedCreateWithoutWorkersInput> | CertificateCreateWithoutWorkersInput[] | CertificateUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutWorkersInput | CertificateCreateOrConnectWithoutWorkersInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CrewWorkerUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<CrewWorkerCreateWithoutWorkerInput, CrewWorkerUncheckedCreateWithoutWorkerInput> | CrewWorkerCreateWithoutWorkerInput[] | CrewWorkerUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: CrewWorkerCreateOrConnectWithoutWorkerInput | CrewWorkerCreateOrConnectWithoutWorkerInput[]
    upsert?: CrewWorkerUpsertWithWhereUniqueWithoutWorkerInput | CrewWorkerUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: CrewWorkerCreateManyWorkerInputEnvelope
    set?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    disconnect?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    delete?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    connect?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    update?: CrewWorkerUpdateWithWhereUniqueWithoutWorkerInput | CrewWorkerUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: CrewWorkerUpdateManyWithWhereWithoutWorkerInput | CrewWorkerUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: CrewWorkerScalarWhereInput | CrewWorkerScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutWorkersNestedInput = {
    create?: XOR<CertificateCreateWithoutWorkersInput, CertificateUncheckedCreateWithoutWorkersInput> | CertificateCreateWithoutWorkersInput[] | CertificateUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutWorkersInput | CertificateCreateOrConnectWithoutWorkersInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutWorkersInput | CertificateUpsertWithWhereUniqueWithoutWorkersInput[]
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutWorkersInput | CertificateUpdateWithWhereUniqueWithoutWorkersInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutWorkersInput | CertificateUpdateManyWithWhereWithoutWorkersInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CrewWorkerUncheckedUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<CrewWorkerCreateWithoutWorkerInput, CrewWorkerUncheckedCreateWithoutWorkerInput> | CrewWorkerCreateWithoutWorkerInput[] | CrewWorkerUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: CrewWorkerCreateOrConnectWithoutWorkerInput | CrewWorkerCreateOrConnectWithoutWorkerInput[]
    upsert?: CrewWorkerUpsertWithWhereUniqueWithoutWorkerInput | CrewWorkerUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: CrewWorkerCreateManyWorkerInputEnvelope
    set?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    disconnect?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    delete?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    connect?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    update?: CrewWorkerUpdateWithWhereUniqueWithoutWorkerInput | CrewWorkerUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: CrewWorkerUpdateManyWithWhereWithoutWorkerInput | CrewWorkerUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: CrewWorkerScalarWhereInput | CrewWorkerScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutWorkersNestedInput = {
    create?: XOR<CertificateCreateWithoutWorkersInput, CertificateUncheckedCreateWithoutWorkersInput> | CertificateCreateWithoutWorkersInput[] | CertificateUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutWorkersInput | CertificateCreateOrConnectWithoutWorkersInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutWorkersInput | CertificateUpsertWithWhereUniqueWithoutWorkersInput[]
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutWorkersInput | CertificateUpdateWithWhereUniqueWithoutWorkersInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutWorkersInput | CertificateUpdateManyWithWhereWithoutWorkersInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutCrewsInput = {
    create?: XOR<ProjectCreateWithoutCrewsInput, ProjectUncheckedCreateWithoutCrewsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCrewsInput
    connect?: ProjectWhereUniqueInput
  }

  export type CrewWorkerCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewWorkerCreateWithoutCrewInput, CrewWorkerUncheckedCreateWithoutCrewInput> | CrewWorkerCreateWithoutCrewInput[] | CrewWorkerUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewWorkerCreateOrConnectWithoutCrewInput | CrewWorkerCreateOrConnectWithoutCrewInput[]
    createMany?: CrewWorkerCreateManyCrewInputEnvelope
    connect?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutCrewInput = {
    create?: XOR<LogCreateWithoutCrewInput, LogUncheckedCreateWithoutCrewInput> | LogCreateWithoutCrewInput[] | LogUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: LogCreateOrConnectWithoutCrewInput | LogCreateOrConnectWithoutCrewInput[]
    createMany?: LogCreateManyCrewInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type MaterialRequestCreateNestedManyWithoutCrewInput = {
    create?: XOR<MaterialRequestCreateWithoutCrewInput, MaterialRequestUncheckedCreateWithoutCrewInput> | MaterialRequestCreateWithoutCrewInput[] | MaterialRequestUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutCrewInput | MaterialRequestCreateOrConnectWithoutCrewInput[]
    createMany?: MaterialRequestCreateManyCrewInputEnvelope
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
  }

  export type CommunicationRequestCreateNestedManyWithoutCrewInput = {
    create?: XOR<CommunicationRequestCreateWithoutCrewInput, CommunicationRequestUncheckedCreateWithoutCrewInput> | CommunicationRequestCreateWithoutCrewInput[] | CommunicationRequestUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CommunicationRequestCreateOrConnectWithoutCrewInput | CommunicationRequestCreateOrConnectWithoutCrewInput[]
    createMany?: CommunicationRequestCreateManyCrewInputEnvelope
    connect?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCrewInput = {
    create?: XOR<TaskCreateWithoutCrewInput, TaskUncheckedCreateWithoutCrewInput> | TaskCreateWithoutCrewInput[] | TaskUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCrewInput | TaskCreateOrConnectWithoutCrewInput[]
    createMany?: TaskCreateManyCrewInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CrewWorkerUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewWorkerCreateWithoutCrewInput, CrewWorkerUncheckedCreateWithoutCrewInput> | CrewWorkerCreateWithoutCrewInput[] | CrewWorkerUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewWorkerCreateOrConnectWithoutCrewInput | CrewWorkerCreateOrConnectWithoutCrewInput[]
    createMany?: CrewWorkerCreateManyCrewInputEnvelope
    connect?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<LogCreateWithoutCrewInput, LogUncheckedCreateWithoutCrewInput> | LogCreateWithoutCrewInput[] | LogUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: LogCreateOrConnectWithoutCrewInput | LogCreateOrConnectWithoutCrewInput[]
    createMany?: LogCreateManyCrewInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type MaterialRequestUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<MaterialRequestCreateWithoutCrewInput, MaterialRequestUncheckedCreateWithoutCrewInput> | MaterialRequestCreateWithoutCrewInput[] | MaterialRequestUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutCrewInput | MaterialRequestCreateOrConnectWithoutCrewInput[]
    createMany?: MaterialRequestCreateManyCrewInputEnvelope
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
  }

  export type CommunicationRequestUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<CommunicationRequestCreateWithoutCrewInput, CommunicationRequestUncheckedCreateWithoutCrewInput> | CommunicationRequestCreateWithoutCrewInput[] | CommunicationRequestUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CommunicationRequestCreateOrConnectWithoutCrewInput | CommunicationRequestCreateOrConnectWithoutCrewInput[]
    createMany?: CommunicationRequestCreateManyCrewInputEnvelope
    connect?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<TaskCreateWithoutCrewInput, TaskUncheckedCreateWithoutCrewInput> | TaskCreateWithoutCrewInput[] | TaskUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCrewInput | TaskCreateOrConnectWithoutCrewInput[]
    createMany?: TaskCreateManyCrewInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type EnumCrewStateFieldUpdateOperationsInput = {
    set?: $Enums.CrewState
  }

  export type ProjectUpdateOneWithoutCrewsNestedInput = {
    create?: XOR<ProjectCreateWithoutCrewsInput, ProjectUncheckedCreateWithoutCrewsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCrewsInput
    upsert?: ProjectUpsertWithoutCrewsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCrewsInput, ProjectUpdateWithoutCrewsInput>, ProjectUncheckedUpdateWithoutCrewsInput>
  }

  export type CrewWorkerUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewWorkerCreateWithoutCrewInput, CrewWorkerUncheckedCreateWithoutCrewInput> | CrewWorkerCreateWithoutCrewInput[] | CrewWorkerUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewWorkerCreateOrConnectWithoutCrewInput | CrewWorkerCreateOrConnectWithoutCrewInput[]
    upsert?: CrewWorkerUpsertWithWhereUniqueWithoutCrewInput | CrewWorkerUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewWorkerCreateManyCrewInputEnvelope
    set?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    disconnect?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    delete?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    connect?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    update?: CrewWorkerUpdateWithWhereUniqueWithoutCrewInput | CrewWorkerUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewWorkerUpdateManyWithWhereWithoutCrewInput | CrewWorkerUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewWorkerScalarWhereInput | CrewWorkerScalarWhereInput[]
  }

  export type LogUpdateManyWithoutCrewNestedInput = {
    create?: XOR<LogCreateWithoutCrewInput, LogUncheckedCreateWithoutCrewInput> | LogCreateWithoutCrewInput[] | LogUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: LogCreateOrConnectWithoutCrewInput | LogCreateOrConnectWithoutCrewInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutCrewInput | LogUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: LogCreateManyCrewInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutCrewInput | LogUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: LogUpdateManyWithWhereWithoutCrewInput | LogUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type MaterialRequestUpdateManyWithoutCrewNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutCrewInput, MaterialRequestUncheckedCreateWithoutCrewInput> | MaterialRequestCreateWithoutCrewInput[] | MaterialRequestUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutCrewInput | MaterialRequestCreateOrConnectWithoutCrewInput[]
    upsert?: MaterialRequestUpsertWithWhereUniqueWithoutCrewInput | MaterialRequestUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: MaterialRequestCreateManyCrewInputEnvelope
    set?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    disconnect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    delete?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    update?: MaterialRequestUpdateWithWhereUniqueWithoutCrewInput | MaterialRequestUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: MaterialRequestUpdateManyWithWhereWithoutCrewInput | MaterialRequestUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
  }

  export type CommunicationRequestUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CommunicationRequestCreateWithoutCrewInput, CommunicationRequestUncheckedCreateWithoutCrewInput> | CommunicationRequestCreateWithoutCrewInput[] | CommunicationRequestUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CommunicationRequestCreateOrConnectWithoutCrewInput | CommunicationRequestCreateOrConnectWithoutCrewInput[]
    upsert?: CommunicationRequestUpsertWithWhereUniqueWithoutCrewInput | CommunicationRequestUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CommunicationRequestCreateManyCrewInputEnvelope
    set?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    disconnect?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    delete?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    connect?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    update?: CommunicationRequestUpdateWithWhereUniqueWithoutCrewInput | CommunicationRequestUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CommunicationRequestUpdateManyWithWhereWithoutCrewInput | CommunicationRequestUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CommunicationRequestScalarWhereInput | CommunicationRequestScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCrewNestedInput = {
    create?: XOR<TaskCreateWithoutCrewInput, TaskUncheckedCreateWithoutCrewInput> | TaskCreateWithoutCrewInput[] | TaskUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCrewInput | TaskCreateOrConnectWithoutCrewInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCrewInput | TaskUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: TaskCreateManyCrewInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCrewInput | TaskUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCrewInput | TaskUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CrewWorkerUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewWorkerCreateWithoutCrewInput, CrewWorkerUncheckedCreateWithoutCrewInput> | CrewWorkerCreateWithoutCrewInput[] | CrewWorkerUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewWorkerCreateOrConnectWithoutCrewInput | CrewWorkerCreateOrConnectWithoutCrewInput[]
    upsert?: CrewWorkerUpsertWithWhereUniqueWithoutCrewInput | CrewWorkerUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewWorkerCreateManyCrewInputEnvelope
    set?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    disconnect?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    delete?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    connect?: CrewWorkerWhereUniqueInput | CrewWorkerWhereUniqueInput[]
    update?: CrewWorkerUpdateWithWhereUniqueWithoutCrewInput | CrewWorkerUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewWorkerUpdateManyWithWhereWithoutCrewInput | CrewWorkerUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewWorkerScalarWhereInput | CrewWorkerScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<LogCreateWithoutCrewInput, LogUncheckedCreateWithoutCrewInput> | LogCreateWithoutCrewInput[] | LogUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: LogCreateOrConnectWithoutCrewInput | LogCreateOrConnectWithoutCrewInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutCrewInput | LogUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: LogCreateManyCrewInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutCrewInput | LogUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: LogUpdateManyWithWhereWithoutCrewInput | LogUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type MaterialRequestUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutCrewInput, MaterialRequestUncheckedCreateWithoutCrewInput> | MaterialRequestCreateWithoutCrewInput[] | MaterialRequestUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutCrewInput | MaterialRequestCreateOrConnectWithoutCrewInput[]
    upsert?: MaterialRequestUpsertWithWhereUniqueWithoutCrewInput | MaterialRequestUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: MaterialRequestCreateManyCrewInputEnvelope
    set?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    disconnect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    delete?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    update?: MaterialRequestUpdateWithWhereUniqueWithoutCrewInput | MaterialRequestUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: MaterialRequestUpdateManyWithWhereWithoutCrewInput | MaterialRequestUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
  }

  export type CommunicationRequestUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CommunicationRequestCreateWithoutCrewInput, CommunicationRequestUncheckedCreateWithoutCrewInput> | CommunicationRequestCreateWithoutCrewInput[] | CommunicationRequestUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CommunicationRequestCreateOrConnectWithoutCrewInput | CommunicationRequestCreateOrConnectWithoutCrewInput[]
    upsert?: CommunicationRequestUpsertWithWhereUniqueWithoutCrewInput | CommunicationRequestUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CommunicationRequestCreateManyCrewInputEnvelope
    set?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    disconnect?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    delete?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    connect?: CommunicationRequestWhereUniqueInput | CommunicationRequestWhereUniqueInput[]
    update?: CommunicationRequestUpdateWithWhereUniqueWithoutCrewInput | CommunicationRequestUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CommunicationRequestUpdateManyWithWhereWithoutCrewInput | CommunicationRequestUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CommunicationRequestScalarWhereInput | CommunicationRequestScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<TaskCreateWithoutCrewInput, TaskUncheckedCreateWithoutCrewInput> | TaskCreateWithoutCrewInput[] | TaskUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCrewInput | TaskCreateOrConnectWithoutCrewInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCrewInput | TaskUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: TaskCreateManyCrewInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCrewInput | TaskUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCrewInput | TaskUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CrewCreateNestedOneWithoutCrewWorkersInput = {
    create?: XOR<CrewCreateWithoutCrewWorkersInput, CrewUncheckedCreateWithoutCrewWorkersInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewWorkersInput
    connect?: CrewWhereUniqueInput
  }

  export type WorkerCreateNestedOneWithoutCrewWorkersInput = {
    create?: XOR<WorkerCreateWithoutCrewWorkersInput, WorkerUncheckedCreateWithoutCrewWorkersInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutCrewWorkersInput
    connect?: WorkerWhereUniqueInput
  }

  export type CrewUpdateOneRequiredWithoutCrewWorkersNestedInput = {
    create?: XOR<CrewCreateWithoutCrewWorkersInput, CrewUncheckedCreateWithoutCrewWorkersInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewWorkersInput
    upsert?: CrewUpsertWithoutCrewWorkersInput
    connect?: CrewWhereUniqueInput
    update?: XOR<XOR<CrewUpdateToOneWithWhereWithoutCrewWorkersInput, CrewUpdateWithoutCrewWorkersInput>, CrewUncheckedUpdateWithoutCrewWorkersInput>
  }

  export type WorkerUpdateOneRequiredWithoutCrewWorkersNestedInput = {
    create?: XOR<WorkerCreateWithoutCrewWorkersInput, WorkerUncheckedCreateWithoutCrewWorkersInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutCrewWorkersInput
    upsert?: WorkerUpsertWithoutCrewWorkersInput
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutCrewWorkersInput, WorkerUpdateWithoutCrewWorkersInput>, WorkerUncheckedUpdateWithoutCrewWorkersInput>
  }

  export type CrewCreateNestedOneWithoutLogsInput = {
    create?: XOR<CrewCreateWithoutLogsInput, CrewUncheckedCreateWithoutLogsInput>
    connectOrCreate?: CrewCreateOrConnectWithoutLogsInput
    connect?: CrewWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutLogsInput = {
    create?: XOR<ProjectCreateWithoutLogsInput, ProjectUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLogsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type CrewUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<CrewCreateWithoutLogsInput, CrewUncheckedCreateWithoutLogsInput>
    connectOrCreate?: CrewCreateOrConnectWithoutLogsInput
    upsert?: CrewUpsertWithoutLogsInput
    connect?: CrewWhereUniqueInput
    update?: XOR<XOR<CrewUpdateToOneWithWhereWithoutLogsInput, CrewUpdateWithoutLogsInput>, CrewUncheckedUpdateWithoutLogsInput>
  }

  export type ProjectUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ProjectCreateWithoutLogsInput, ProjectUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLogsInput
    upsert?: ProjectUpsertWithoutLogsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLogsInput, ProjectUpdateWithoutLogsInput>, ProjectUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type MaterialRequestCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MaterialRequestCreateWithoutMaterialInput, MaterialRequestUncheckedCreateWithoutMaterialInput> | MaterialRequestCreateWithoutMaterialInput[] | MaterialRequestUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutMaterialInput | MaterialRequestCreateOrConnectWithoutMaterialInput[]
    createMany?: MaterialRequestCreateManyMaterialInputEnvelope
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
  }

  export type MaterialRequestUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MaterialRequestCreateWithoutMaterialInput, MaterialRequestUncheckedCreateWithoutMaterialInput> | MaterialRequestCreateWithoutMaterialInput[] | MaterialRequestUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutMaterialInput | MaterialRequestCreateOrConnectWithoutMaterialInput[]
    createMany?: MaterialRequestCreateManyMaterialInputEnvelope
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MaterialRequestUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutMaterialInput, MaterialRequestUncheckedCreateWithoutMaterialInput> | MaterialRequestCreateWithoutMaterialInput[] | MaterialRequestUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutMaterialInput | MaterialRequestCreateOrConnectWithoutMaterialInput[]
    upsert?: MaterialRequestUpsertWithWhereUniqueWithoutMaterialInput | MaterialRequestUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MaterialRequestCreateManyMaterialInputEnvelope
    set?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    disconnect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    delete?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    update?: MaterialRequestUpdateWithWhereUniqueWithoutMaterialInput | MaterialRequestUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MaterialRequestUpdateManyWithWhereWithoutMaterialInput | MaterialRequestUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
  }

  export type MaterialRequestUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MaterialRequestCreateWithoutMaterialInput, MaterialRequestUncheckedCreateWithoutMaterialInput> | MaterialRequestCreateWithoutMaterialInput[] | MaterialRequestUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialRequestCreateOrConnectWithoutMaterialInput | MaterialRequestCreateOrConnectWithoutMaterialInput[]
    upsert?: MaterialRequestUpsertWithWhereUniqueWithoutMaterialInput | MaterialRequestUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MaterialRequestCreateManyMaterialInputEnvelope
    set?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    disconnect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    delete?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    connect?: MaterialRequestWhereUniqueInput | MaterialRequestWhereUniqueInput[]
    update?: MaterialRequestUpdateWithWhereUniqueWithoutMaterialInput | MaterialRequestUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MaterialRequestUpdateManyWithWhereWithoutMaterialInput | MaterialRequestUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
  }

  export type MaterialCreateNestedOneWithoutRequestsInput = {
    create?: XOR<MaterialCreateWithoutRequestsInput, MaterialUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutRequestsInput
    connect?: MaterialWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutMaterialRequestsInput = {
    create?: XOR<ProjectCreateWithoutMaterialRequestsInput, ProjectUncheckedCreateWithoutMaterialRequestsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMaterialRequestsInput
    connect?: ProjectWhereUniqueInput
  }

  export type CrewCreateNestedOneWithoutMaterialRequestsInput = {
    create?: XOR<CrewCreateWithoutMaterialRequestsInput, CrewUncheckedCreateWithoutMaterialRequestsInput>
    connectOrCreate?: CrewCreateOrConnectWithoutMaterialRequestsInput
    connect?: CrewWhereUniqueInput
  }

  export type EnumMaterialRequestStateFieldUpdateOperationsInput = {
    set?: $Enums.MaterialRequestState
  }

  export type MaterialUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<MaterialCreateWithoutRequestsInput, MaterialUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutRequestsInput
    upsert?: MaterialUpsertWithoutRequestsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutRequestsInput, MaterialUpdateWithoutRequestsInput>, MaterialUncheckedUpdateWithoutRequestsInput>
  }

  export type ProjectUpdateOneRequiredWithoutMaterialRequestsNestedInput = {
    create?: XOR<ProjectCreateWithoutMaterialRequestsInput, ProjectUncheckedCreateWithoutMaterialRequestsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMaterialRequestsInput
    upsert?: ProjectUpsertWithoutMaterialRequestsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMaterialRequestsInput, ProjectUpdateWithoutMaterialRequestsInput>, ProjectUncheckedUpdateWithoutMaterialRequestsInput>
  }

  export type CrewUpdateOneRequiredWithoutMaterialRequestsNestedInput = {
    create?: XOR<CrewCreateWithoutMaterialRequestsInput, CrewUncheckedCreateWithoutMaterialRequestsInput>
    connectOrCreate?: CrewCreateOrConnectWithoutMaterialRequestsInput
    upsert?: CrewUpsertWithoutMaterialRequestsInput
    connect?: CrewWhereUniqueInput
    update?: XOR<XOR<CrewUpdateToOneWithWhereWithoutMaterialRequestsInput, CrewUpdateWithoutMaterialRequestsInput>, CrewUncheckedUpdateWithoutMaterialRequestsInput>
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserCreateNestedOneWithoutRequestsInput = {
    create?: XOR<UserCreateWithoutRequestsInput, UserUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type CrewCreateNestedOneWithoutCommunicationRequestsInput = {
    create?: XOR<CrewCreateWithoutCommunicationRequestsInput, CrewUncheckedCreateWithoutCommunicationRequestsInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCommunicationRequestsInput
    connect?: CrewWhereUniqueInput
  }

  export type EnumRequestTypeFieldUpdateOperationsInput = {
    set?: $Enums.RequestType
  }

  export type EnumRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequestStatus
  }

  export type UserUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<UserCreateWithoutRequestsInput, UserUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestsInput
    upsert?: UserUpsertWithoutRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequestsInput, UserUpdateWithoutRequestsInput>, UserUncheckedUpdateWithoutRequestsInput>
  }

  export type CrewUpdateOneRequiredWithoutCommunicationRequestsNestedInput = {
    create?: XOR<CrewCreateWithoutCommunicationRequestsInput, CrewUncheckedCreateWithoutCommunicationRequestsInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCommunicationRequestsInput
    upsert?: CrewUpsertWithoutCommunicationRequestsInput
    connect?: CrewWhereUniqueInput
    update?: XOR<XOR<CrewUpdateToOneWithWhereWithoutCommunicationRequestsInput, CrewUpdateWithoutCommunicationRequestsInput>, CrewUncheckedUpdateWithoutCommunicationRequestsInput>
  }

  export type WorkerCreateNestedManyWithoutCertificatesInput = {
    create?: XOR<WorkerCreateWithoutCertificatesInput, WorkerUncheckedCreateWithoutCertificatesInput> | WorkerCreateWithoutCertificatesInput[] | WorkerUncheckedCreateWithoutCertificatesInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCertificatesInput | WorkerCreateOrConnectWithoutCertificatesInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type WorkerUncheckedCreateNestedManyWithoutCertificatesInput = {
    create?: XOR<WorkerCreateWithoutCertificatesInput, WorkerUncheckedCreateWithoutCertificatesInput> | WorkerCreateWithoutCertificatesInput[] | WorkerUncheckedCreateWithoutCertificatesInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCertificatesInput | WorkerCreateOrConnectWithoutCertificatesInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type WorkerUpdateManyWithoutCertificatesNestedInput = {
    create?: XOR<WorkerCreateWithoutCertificatesInput, WorkerUncheckedCreateWithoutCertificatesInput> | WorkerCreateWithoutCertificatesInput[] | WorkerUncheckedCreateWithoutCertificatesInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCertificatesInput | WorkerCreateOrConnectWithoutCertificatesInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutCertificatesInput | WorkerUpsertWithWhereUniqueWithoutCertificatesInput[]
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutCertificatesInput | WorkerUpdateWithWhereUniqueWithoutCertificatesInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutCertificatesInput | WorkerUpdateManyWithWhereWithoutCertificatesInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type WorkerUncheckedUpdateManyWithoutCertificatesNestedInput = {
    create?: XOR<WorkerCreateWithoutCertificatesInput, WorkerUncheckedCreateWithoutCertificatesInput> | WorkerCreateWithoutCertificatesInput[] | WorkerUncheckedCreateWithoutCertificatesInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCertificatesInput | WorkerCreateOrConnectWithoutCertificatesInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutCertificatesInput | WorkerUpsertWithWhereUniqueWithoutCertificatesInput[]
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutCertificatesInput | WorkerUpdateWithWhereUniqueWithoutCertificatesInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutCertificatesInput | WorkerUpdateManyWithWhereWithoutCertificatesInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMilestonesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMilestonesInput
    upsert?: ProjectUpsertWithoutMilestonesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMilestonesInput, ProjectUpdateWithoutMilestonesInput>, ProjectUncheckedUpdateWithoutMilestonesInput>
  }

  export type CrewCreateNestedOneWithoutTasksInput = {
    create?: XOR<CrewCreateWithoutTasksInput, CrewUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CrewCreateOrConnectWithoutTasksInput
    connect?: CrewWhereUniqueInput
  }

  export type CrewUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<CrewCreateWithoutTasksInput, CrewUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CrewCreateOrConnectWithoutTasksInput
    upsert?: CrewUpsertWithoutTasksInput
    connect?: CrewWhereUniqueInput
    update?: XOR<XOR<CrewUpdateToOneWithWhereWithoutTasksInput, CrewUpdateWithoutTasksInput>, CrewUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ProjectCreateWithoutAuditLogsInput, ProjectUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAuditLogsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<ProjectCreateWithoutAuditLogsInput, ProjectUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAuditLogsInput
    upsert?: ProjectUpsertWithoutAuditLogsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAuditLogsInput, ProjectUpdateWithoutAuditLogsInput>, ProjectUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCrewStateFilter<$PrismaModel = never> = {
    equals?: $Enums.CrewState | EnumCrewStateFieldRefInput<$PrismaModel>
    in?: $Enums.CrewState[] | ListEnumCrewStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrewState[] | ListEnumCrewStateFieldRefInput<$PrismaModel>
    not?: NestedEnumCrewStateFilter<$PrismaModel> | $Enums.CrewState
  }

  export type NestedEnumCrewStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CrewState | EnumCrewStateFieldRefInput<$PrismaModel>
    in?: $Enums.CrewState[] | ListEnumCrewStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrewState[] | ListEnumCrewStateFieldRefInput<$PrismaModel>
    not?: NestedEnumCrewStateWithAggregatesFilter<$PrismaModel> | $Enums.CrewState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCrewStateFilter<$PrismaModel>
    _max?: NestedEnumCrewStateFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumMaterialRequestStateFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialRequestState | EnumMaterialRequestStateFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialRequestState[] | ListEnumMaterialRequestStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialRequestState[] | ListEnumMaterialRequestStateFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialRequestStateFilter<$PrismaModel> | $Enums.MaterialRequestState
  }

  export type NestedEnumMaterialRequestStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialRequestState | EnumMaterialRequestStateFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialRequestState[] | ListEnumMaterialRequestStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialRequestState[] | ListEnumMaterialRequestStateFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialRequestStateWithAggregatesFilter<$PrismaModel> | $Enums.MaterialRequestState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialRequestStateFilter<$PrismaModel>
    _max?: NestedEnumMaterialRequestStateFilter<$PrismaModel>
  }

  export type NestedEnumRequestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestType | EnumRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestTypeFilter<$PrismaModel> | $Enums.RequestType
  }

  export type NestedEnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type NestedEnumRequestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestType | EnumRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestTypeWithAggregatesFilter<$PrismaModel> | $Enums.RequestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestTypeFilter<$PrismaModel>
    _max?: NestedEnumRequestTypeFilter<$PrismaModel>
  }

  export type NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type ProjectCreateWithoutJefeInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    crews?: CrewCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutJefeInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutJefeInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutJefeInput, ProjectUncheckedCreateWithoutJefeInput>
  }

  export type ProjectCreateManyJefeInputEnvelope = {
    data: ProjectCreateManyJefeInput | ProjectCreateManyJefeInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutResponsableInput = {
    id?: string
    descripcion?: string | null
    incidentes?: string | null
    consumo_materiales?: string | null
    avance?: string | null
    fecha?: Date | string
    actividades?: string | null
    materiales_consumidos?: string | null
    tiempos_trabajo?: string | null
    observaciones?: string | null
    estado_herramientas?: string | null
    crew: CrewCreateNestedOneWithoutLogsInput
    project: ProjectCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateWithoutResponsableInput = {
    id?: string
    crewId: string
    projectId: string
    descripcion?: string | null
    incidentes?: string | null
    consumo_materiales?: string | null
    avance?: string | null
    fecha?: Date | string
    actividades?: string | null
    materiales_consumidos?: string | null
    tiempos_trabajo?: string | null
    observaciones?: string | null
    estado_herramientas?: string | null
  }

  export type LogCreateOrConnectWithoutResponsableInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutResponsableInput, LogUncheckedCreateWithoutResponsableInput>
  }

  export type LogCreateManyResponsableInputEnvelope = {
    data: LogCreateManyResponsableInput | LogCreateManyResponsableInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    conversationId?: string | null
    createdAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    receiverId: string
    content: string
    conversationId?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutReceiverInput = {
    id?: string
    content: string
    conversationId?: string | null
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    senderId: string
    content: string
    conversationId?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateManyReceiverInputEnvelope = {
    data: MessageCreateManyReceiverInput | MessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationRequestCreateWithoutSenderInput = {
    id?: string
    requestType: $Enums.RequestType
    description: string
    urgency?: string
    estado?: $Enums.RequestStatus
    respuesta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    crew: CrewCreateNestedOneWithoutCommunicationRequestsInput
  }

  export type CommunicationRequestUncheckedCreateWithoutSenderInput = {
    id?: string
    requestType: $Enums.RequestType
    description: string
    urgency?: string
    crewId: string
    estado?: $Enums.RequestStatus
    respuesta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationRequestCreateOrConnectWithoutSenderInput = {
    where: CommunicationRequestWhereUniqueInput
    create: XOR<CommunicationRequestCreateWithoutSenderInput, CommunicationRequestUncheckedCreateWithoutSenderInput>
  }

  export type CommunicationRequestCreateManySenderInputEnvelope = {
    data: CommunicationRequestCreateManySenderInput | CommunicationRequestCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutJefeInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutJefeInput, ProjectUncheckedUpdateWithoutJefeInput>
    create: XOR<ProjectCreateWithoutJefeInput, ProjectUncheckedCreateWithoutJefeInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutJefeInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutJefeInput, ProjectUncheckedUpdateWithoutJefeInput>
  }

  export type ProjectUpdateManyWithWhereWithoutJefeInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutJefeInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    tipo_obra?: StringFilter<"Project"> | string
    complejidad?: StringFilter<"Project"> | string
    duracion_estimada?: IntNullableFilter<"Project"> | number | null
    fecha_inicio?: DateTimeNullableFilter<"Project"> | Date | string | null
    fecha_termino?: DateTimeNullableFilter<"Project"> | Date | string | null
    zona_trabajo?: StringFilter<"Project"> | string
    estado?: StringFilter<"Project"> | string
    presupuesto?: FloatNullableFilter<"Project"> | number | null
    supervisor?: StringNullableFilter<"Project"> | string | null
    descripcion_tecnica?: StringNullableFilter<"Project"> | string | null
    jefeId?: StringNullableFilter<"Project"> | string | null
  }

  export type LogUpsertWithWhereUniqueWithoutResponsableInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutResponsableInput, LogUncheckedUpdateWithoutResponsableInput>
    create: XOR<LogCreateWithoutResponsableInput, LogUncheckedCreateWithoutResponsableInput>
  }

  export type LogUpdateWithWhereUniqueWithoutResponsableInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutResponsableInput, LogUncheckedUpdateWithoutResponsableInput>
  }

  export type LogUpdateManyWithWhereWithoutResponsableInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutResponsableInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: StringFilter<"Log"> | string
    crewId?: StringFilter<"Log"> | string
    projectId?: StringFilter<"Log"> | string
    descripcion?: StringNullableFilter<"Log"> | string | null
    incidentes?: StringNullableFilter<"Log"> | string | null
    consumo_materiales?: StringNullableFilter<"Log"> | string | null
    avance?: StringNullableFilter<"Log"> | string | null
    fecha?: DateTimeFilter<"Log"> | Date | string
    responsableId?: StringFilter<"Log"> | string
    actividades?: StringNullableFilter<"Log"> | string | null
    materiales_consumidos?: StringNullableFilter<"Log"> | string | null
    tiempos_trabajo?: StringNullableFilter<"Log"> | string | null
    observaciones?: StringNullableFilter<"Log"> | string | null
    estado_herramientas?: StringNullableFilter<"Log"> | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    conversationId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type CommunicationRequestUpsertWithWhereUniqueWithoutSenderInput = {
    where: CommunicationRequestWhereUniqueInput
    update: XOR<CommunicationRequestUpdateWithoutSenderInput, CommunicationRequestUncheckedUpdateWithoutSenderInput>
    create: XOR<CommunicationRequestCreateWithoutSenderInput, CommunicationRequestUncheckedCreateWithoutSenderInput>
  }

  export type CommunicationRequestUpdateWithWhereUniqueWithoutSenderInput = {
    where: CommunicationRequestWhereUniqueInput
    data: XOR<CommunicationRequestUpdateWithoutSenderInput, CommunicationRequestUncheckedUpdateWithoutSenderInput>
  }

  export type CommunicationRequestUpdateManyWithWhereWithoutSenderInput = {
    where: CommunicationRequestScalarWhereInput
    data: XOR<CommunicationRequestUpdateManyMutationInput, CommunicationRequestUncheckedUpdateManyWithoutSenderInput>
  }

  export type CommunicationRequestScalarWhereInput = {
    AND?: CommunicationRequestScalarWhereInput | CommunicationRequestScalarWhereInput[]
    OR?: CommunicationRequestScalarWhereInput[]
    NOT?: CommunicationRequestScalarWhereInput | CommunicationRequestScalarWhereInput[]
    id?: StringFilter<"CommunicationRequest"> | string
    senderId?: StringFilter<"CommunicationRequest"> | string
    requestType?: EnumRequestTypeFilter<"CommunicationRequest"> | $Enums.RequestType
    description?: StringFilter<"CommunicationRequest"> | string
    urgency?: StringFilter<"CommunicationRequest"> | string
    crewId?: StringFilter<"CommunicationRequest"> | string
    estado?: EnumRequestStatusFilter<"CommunicationRequest"> | $Enums.RequestStatus
    respuesta?: StringNullableFilter<"CommunicationRequest"> | string | null
    createdAt?: DateTimeFilter<"CommunicationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CommunicationRequest"> | Date | string
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    logs?: LogCreateNestedManyWithoutResponsableInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    requests?: CommunicationRequestCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    logs?: LogUncheckedCreateNestedManyWithoutResponsableInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    requests?: CommunicationRequestUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type CrewCreateWithoutProjectInput = {
    id?: string
    name: string
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    crewWorkers?: CrewWorkerCreateNestedManyWithoutCrewInput
    logs?: LogCreateNestedManyWithoutCrewInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutCrewInput
    communicationRequests?: CommunicationRequestCreateNestedManyWithoutCrewInput
    tasks?: TaskCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    crewWorkers?: CrewWorkerUncheckedCreateNestedManyWithoutCrewInput
    logs?: LogUncheckedCreateNestedManyWithoutCrewInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutCrewInput
    communicationRequests?: CommunicationRequestUncheckedCreateNestedManyWithoutCrewInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutProjectInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutProjectInput, CrewUncheckedCreateWithoutProjectInput>
  }

  export type CrewCreateManyProjectInputEnvelope = {
    data: CrewCreateManyProjectInput | CrewCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MaterialRequestCreateWithoutProjectInput = {
    id?: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt?: Date | string
    material: MaterialCreateNestedOneWithoutRequestsInput
    crew: CrewCreateNestedOneWithoutMaterialRequestsInput
  }

  export type MaterialRequestUncheckedCreateWithoutProjectInput = {
    id?: string
    materialId: string
    crewId: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt?: Date | string
  }

  export type MaterialRequestCreateOrConnectWithoutProjectInput = {
    where: MaterialRequestWhereUniqueInput
    create: XOR<MaterialRequestCreateWithoutProjectInput, MaterialRequestUncheckedCreateWithoutProjectInput>
  }

  export type MaterialRequestCreateManyProjectInputEnvelope = {
    data: MaterialRequestCreateManyProjectInput | MaterialRequestCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutProjectInput = {
    id?: string
    descripcion?: string | null
    incidentes?: string | null
    consumo_materiales?: string | null
    avance?: string | null
    fecha?: Date | string
    actividades?: string | null
    materiales_consumidos?: string | null
    tiempos_trabajo?: string | null
    observaciones?: string | null
    estado_herramientas?: string | null
    crew: CrewCreateNestedOneWithoutLogsInput
    responsable: UserCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateWithoutProjectInput = {
    id?: string
    crewId: string
    descripcion?: string | null
    incidentes?: string | null
    consumo_materiales?: string | null
    avance?: string | null
    fecha?: Date | string
    responsableId: string
    actividades?: string | null
    materiales_consumidos?: string | null
    tiempos_trabajo?: string | null
    observaciones?: string | null
    estado_herramientas?: string | null
  }

  export type LogCreateOrConnectWithoutProjectInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutProjectInput, LogUncheckedCreateWithoutProjectInput>
  }

  export type LogCreateManyProjectInputEnvelope = {
    data: LogCreateManyProjectInput | LogCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MilestoneCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    targetDate: Date | string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    targetDate: Date | string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneCreateOrConnectWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput>
  }

  export type MilestoneCreateManyProjectInputEnvelope = {
    data: MilestoneCreateManyProjectInput | MilestoneCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutProjectInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId?: string | null
    changes?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId?: string | null
    changes?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutProjectInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutProjectInput, AuditLogUncheckedCreateWithoutProjectInput>
  }

  export type AuditLogCreateManyProjectInputEnvelope = {
    data: AuditLogCreateManyProjectInput | AuditLogCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: LogUpdateManyWithoutResponsableNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    requests?: CommunicationRequestUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: LogUncheckedUpdateManyWithoutResponsableNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    requests?: CommunicationRequestUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type CrewUpsertWithWhereUniqueWithoutProjectInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutProjectInput, CrewUncheckedUpdateWithoutProjectInput>
    create: XOR<CrewCreateWithoutProjectInput, CrewUncheckedCreateWithoutProjectInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutProjectInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutProjectInput, CrewUncheckedUpdateWithoutProjectInput>
  }

  export type CrewUpdateManyWithWhereWithoutProjectInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutProjectInput>
  }

  export type CrewScalarWhereInput = {
    AND?: CrewScalarWhereInput | CrewScalarWhereInput[]
    OR?: CrewScalarWhereInput[]
    NOT?: CrewScalarWhereInput | CrewScalarWhereInput[]
    id?: StringFilter<"Crew"> | string
    name?: StringFilter<"Crew"> | string
    projectId?: StringNullableFilter<"Crew"> | string | null
    fecha_inicio?: DateTimeNullableFilter<"Crew"> | Date | string | null
    estado?: EnumCrewStateFilter<"Crew"> | $Enums.CrewState
    zona_trabajo?: StringNullableFilter<"Crew"> | string | null
    fecha_plazo?: DateTimeNullableFilter<"Crew"> | Date | string | null
    cantidad_trabajadores?: IntNullableFilter<"Crew"> | number | null
  }

  export type MaterialRequestUpsertWithWhereUniqueWithoutProjectInput = {
    where: MaterialRequestWhereUniqueInput
    update: XOR<MaterialRequestUpdateWithoutProjectInput, MaterialRequestUncheckedUpdateWithoutProjectInput>
    create: XOR<MaterialRequestCreateWithoutProjectInput, MaterialRequestUncheckedCreateWithoutProjectInput>
  }

  export type MaterialRequestUpdateWithWhereUniqueWithoutProjectInput = {
    where: MaterialRequestWhereUniqueInput
    data: XOR<MaterialRequestUpdateWithoutProjectInput, MaterialRequestUncheckedUpdateWithoutProjectInput>
  }

  export type MaterialRequestUpdateManyWithWhereWithoutProjectInput = {
    where: MaterialRequestScalarWhereInput
    data: XOR<MaterialRequestUpdateManyMutationInput, MaterialRequestUncheckedUpdateManyWithoutProjectInput>
  }

  export type MaterialRequestScalarWhereInput = {
    AND?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
    OR?: MaterialRequestScalarWhereInput[]
    NOT?: MaterialRequestScalarWhereInput | MaterialRequestScalarWhereInput[]
    id?: StringFilter<"MaterialRequest"> | string
    materialId?: StringFilter<"MaterialRequest"> | string
    projectId?: StringFilter<"MaterialRequest"> | string
    crewId?: StringFilter<"MaterialRequest"> | string
    cantidad?: IntFilter<"MaterialRequest"> | number
    estado?: EnumMaterialRequestStateFilter<"MaterialRequest"> | $Enums.MaterialRequestState
    createdAt?: DateTimeFilter<"MaterialRequest"> | Date | string
  }

  export type LogUpsertWithWhereUniqueWithoutProjectInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutProjectInput, LogUncheckedUpdateWithoutProjectInput>
    create: XOR<LogCreateWithoutProjectInput, LogUncheckedCreateWithoutProjectInput>
  }

  export type LogUpdateWithWhereUniqueWithoutProjectInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutProjectInput, LogUncheckedUpdateWithoutProjectInput>
  }

  export type LogUpdateManyWithWhereWithoutProjectInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutProjectInput>
  }

  export type MilestoneUpsertWithWhereUniqueWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutProjectInput, MilestoneUncheckedUpdateWithoutProjectInput>
    create: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutProjectInput, MilestoneUncheckedUpdateWithoutProjectInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutProjectInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutProjectInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: StringFilter<"Milestone"> | string
    projectId?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    targetDate?: DateTimeFilter<"Milestone"> | Date | string
    estado?: StringFilter<"Milestone"> | string
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutProjectInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutProjectInput, AuditLogUncheckedUpdateWithoutProjectInput>
    create: XOR<AuditLogCreateWithoutProjectInput, AuditLogUncheckedCreateWithoutProjectInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutProjectInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutProjectInput, AuditLogUncheckedUpdateWithoutProjectInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutProjectInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutProjectInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    projectId?: StringNullableFilter<"AuditLog"> | string | null
    changes?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type CrewWorkerCreateWithoutWorkerInput = {
    id?: string
    role: string
    fecha_asignacion?: Date | string
    crew: CrewCreateNestedOneWithoutCrewWorkersInput
  }

  export type CrewWorkerUncheckedCreateWithoutWorkerInput = {
    id?: string
    crewId: string
    role: string
    fecha_asignacion?: Date | string
  }

  export type CrewWorkerCreateOrConnectWithoutWorkerInput = {
    where: CrewWorkerWhereUniqueInput
    create: XOR<CrewWorkerCreateWithoutWorkerInput, CrewWorkerUncheckedCreateWithoutWorkerInput>
  }

  export type CrewWorkerCreateManyWorkerInputEnvelope = {
    data: CrewWorkerCreateManyWorkerInput | CrewWorkerCreateManyWorkerInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutWorkersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type CertificateUncheckedCreateWithoutWorkersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutWorkersInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutWorkersInput, CertificateUncheckedCreateWithoutWorkersInput>
  }

  export type CrewWorkerUpsertWithWhereUniqueWithoutWorkerInput = {
    where: CrewWorkerWhereUniqueInput
    update: XOR<CrewWorkerUpdateWithoutWorkerInput, CrewWorkerUncheckedUpdateWithoutWorkerInput>
    create: XOR<CrewWorkerCreateWithoutWorkerInput, CrewWorkerUncheckedCreateWithoutWorkerInput>
  }

  export type CrewWorkerUpdateWithWhereUniqueWithoutWorkerInput = {
    where: CrewWorkerWhereUniqueInput
    data: XOR<CrewWorkerUpdateWithoutWorkerInput, CrewWorkerUncheckedUpdateWithoutWorkerInput>
  }

  export type CrewWorkerUpdateManyWithWhereWithoutWorkerInput = {
    where: CrewWorkerScalarWhereInput
    data: XOR<CrewWorkerUpdateManyMutationInput, CrewWorkerUncheckedUpdateManyWithoutWorkerInput>
  }

  export type CrewWorkerScalarWhereInput = {
    AND?: CrewWorkerScalarWhereInput | CrewWorkerScalarWhereInput[]
    OR?: CrewWorkerScalarWhereInput[]
    NOT?: CrewWorkerScalarWhereInput | CrewWorkerScalarWhereInput[]
    id?: StringFilter<"CrewWorker"> | string
    crewId?: StringFilter<"CrewWorker"> | string
    workerId?: StringFilter<"CrewWorker"> | string
    role?: StringFilter<"CrewWorker"> | string
    fecha_asignacion?: DateTimeFilter<"CrewWorker"> | Date | string
  }

  export type CertificateUpsertWithWhereUniqueWithoutWorkersInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutWorkersInput, CertificateUncheckedUpdateWithoutWorkersInput>
    create: XOR<CertificateCreateWithoutWorkersInput, CertificateUncheckedCreateWithoutWorkersInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutWorkersInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutWorkersInput, CertificateUncheckedUpdateWithoutWorkersInput>
  }

  export type CertificateUpdateManyWithWhereWithoutWorkersInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutWorkersInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    id?: StringFilter<"Certificate"> | string
    name?: StringFilter<"Certificate"> | string
    description?: StringNullableFilter<"Certificate"> | string | null
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
  }

  export type ProjectCreateWithoutCrewsInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefe?: UserCreateNestedOneWithoutProjectsInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCrewsInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefeId?: string | null
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCrewsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCrewsInput, ProjectUncheckedCreateWithoutCrewsInput>
  }

  export type CrewWorkerCreateWithoutCrewInput = {
    id?: string
    role: string
    fecha_asignacion?: Date | string
    worker: WorkerCreateNestedOneWithoutCrewWorkersInput
  }

  export type CrewWorkerUncheckedCreateWithoutCrewInput = {
    id?: string
    workerId: string
    role: string
    fecha_asignacion?: Date | string
  }

  export type CrewWorkerCreateOrConnectWithoutCrewInput = {
    where: CrewWorkerWhereUniqueInput
    create: XOR<CrewWorkerCreateWithoutCrewInput, CrewWorkerUncheckedCreateWithoutCrewInput>
  }

  export type CrewWorkerCreateManyCrewInputEnvelope = {
    data: CrewWorkerCreateManyCrewInput | CrewWorkerCreateManyCrewInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutCrewInput = {
    id?: string
    descripcion?: string | null
    incidentes?: string | null
    consumo_materiales?: string | null
    avance?: string | null
    fecha?: Date | string
    actividades?: string | null
    materiales_consumidos?: string | null
    tiempos_trabajo?: string | null
    observaciones?: string | null
    estado_herramientas?: string | null
    project: ProjectCreateNestedOneWithoutLogsInput
    responsable: UserCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateWithoutCrewInput = {
    id?: string
    projectId: string
    descripcion?: string | null
    incidentes?: string | null
    consumo_materiales?: string | null
    avance?: string | null
    fecha?: Date | string
    responsableId: string
    actividades?: string | null
    materiales_consumidos?: string | null
    tiempos_trabajo?: string | null
    observaciones?: string | null
    estado_herramientas?: string | null
  }

  export type LogCreateOrConnectWithoutCrewInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutCrewInput, LogUncheckedCreateWithoutCrewInput>
  }

  export type LogCreateManyCrewInputEnvelope = {
    data: LogCreateManyCrewInput | LogCreateManyCrewInput[]
    skipDuplicates?: boolean
  }

  export type MaterialRequestCreateWithoutCrewInput = {
    id?: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt?: Date | string
    material: MaterialCreateNestedOneWithoutRequestsInput
    project: ProjectCreateNestedOneWithoutMaterialRequestsInput
  }

  export type MaterialRequestUncheckedCreateWithoutCrewInput = {
    id?: string
    materialId: string
    projectId: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt?: Date | string
  }

  export type MaterialRequestCreateOrConnectWithoutCrewInput = {
    where: MaterialRequestWhereUniqueInput
    create: XOR<MaterialRequestCreateWithoutCrewInput, MaterialRequestUncheckedCreateWithoutCrewInput>
  }

  export type MaterialRequestCreateManyCrewInputEnvelope = {
    data: MaterialRequestCreateManyCrewInput | MaterialRequestCreateManyCrewInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationRequestCreateWithoutCrewInput = {
    id?: string
    requestType: $Enums.RequestType
    description: string
    urgency?: string
    estado?: $Enums.RequestStatus
    respuesta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutRequestsInput
  }

  export type CommunicationRequestUncheckedCreateWithoutCrewInput = {
    id?: string
    senderId: string
    requestType: $Enums.RequestType
    description: string
    urgency?: string
    estado?: $Enums.RequestStatus
    respuesta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationRequestCreateOrConnectWithoutCrewInput = {
    where: CommunicationRequestWhereUniqueInput
    create: XOR<CommunicationRequestCreateWithoutCrewInput, CommunicationRequestUncheckedCreateWithoutCrewInput>
  }

  export type CommunicationRequestCreateManyCrewInputEnvelope = {
    data: CommunicationRequestCreateManyCrewInput | CommunicationRequestCreateManyCrewInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCrewInput = {
    id?: string
    title: string
    description?: string | null
    prioridad?: string
    estado?: string
    fecha_vencimiento?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUncheckedCreateWithoutCrewInput = {
    id?: string
    title: string
    description?: string | null
    prioridad?: string
    estado?: string
    fecha_vencimiento?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutCrewInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCrewInput, TaskUncheckedCreateWithoutCrewInput>
  }

  export type TaskCreateManyCrewInputEnvelope = {
    data: TaskCreateManyCrewInput | TaskCreateManyCrewInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutCrewsInput = {
    update: XOR<ProjectUpdateWithoutCrewsInput, ProjectUncheckedUpdateWithoutCrewsInput>
    create: XOR<ProjectCreateWithoutCrewsInput, ProjectUncheckedCreateWithoutCrewsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCrewsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCrewsInput, ProjectUncheckedUpdateWithoutCrewsInput>
  }

  export type ProjectUpdateWithoutCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefe?: UserUpdateOneWithoutProjectsNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefeId?: NullableStringFieldUpdateOperationsInput | string | null
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CrewWorkerUpsertWithWhereUniqueWithoutCrewInput = {
    where: CrewWorkerWhereUniqueInput
    update: XOR<CrewWorkerUpdateWithoutCrewInput, CrewWorkerUncheckedUpdateWithoutCrewInput>
    create: XOR<CrewWorkerCreateWithoutCrewInput, CrewWorkerUncheckedCreateWithoutCrewInput>
  }

  export type CrewWorkerUpdateWithWhereUniqueWithoutCrewInput = {
    where: CrewWorkerWhereUniqueInput
    data: XOR<CrewWorkerUpdateWithoutCrewInput, CrewWorkerUncheckedUpdateWithoutCrewInput>
  }

  export type CrewWorkerUpdateManyWithWhereWithoutCrewInput = {
    where: CrewWorkerScalarWhereInput
    data: XOR<CrewWorkerUpdateManyMutationInput, CrewWorkerUncheckedUpdateManyWithoutCrewInput>
  }

  export type LogUpsertWithWhereUniqueWithoutCrewInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutCrewInput, LogUncheckedUpdateWithoutCrewInput>
    create: XOR<LogCreateWithoutCrewInput, LogUncheckedCreateWithoutCrewInput>
  }

  export type LogUpdateWithWhereUniqueWithoutCrewInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutCrewInput, LogUncheckedUpdateWithoutCrewInput>
  }

  export type LogUpdateManyWithWhereWithoutCrewInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutCrewInput>
  }

  export type MaterialRequestUpsertWithWhereUniqueWithoutCrewInput = {
    where: MaterialRequestWhereUniqueInput
    update: XOR<MaterialRequestUpdateWithoutCrewInput, MaterialRequestUncheckedUpdateWithoutCrewInput>
    create: XOR<MaterialRequestCreateWithoutCrewInput, MaterialRequestUncheckedCreateWithoutCrewInput>
  }

  export type MaterialRequestUpdateWithWhereUniqueWithoutCrewInput = {
    where: MaterialRequestWhereUniqueInput
    data: XOR<MaterialRequestUpdateWithoutCrewInput, MaterialRequestUncheckedUpdateWithoutCrewInput>
  }

  export type MaterialRequestUpdateManyWithWhereWithoutCrewInput = {
    where: MaterialRequestScalarWhereInput
    data: XOR<MaterialRequestUpdateManyMutationInput, MaterialRequestUncheckedUpdateManyWithoutCrewInput>
  }

  export type CommunicationRequestUpsertWithWhereUniqueWithoutCrewInput = {
    where: CommunicationRequestWhereUniqueInput
    update: XOR<CommunicationRequestUpdateWithoutCrewInput, CommunicationRequestUncheckedUpdateWithoutCrewInput>
    create: XOR<CommunicationRequestCreateWithoutCrewInput, CommunicationRequestUncheckedCreateWithoutCrewInput>
  }

  export type CommunicationRequestUpdateWithWhereUniqueWithoutCrewInput = {
    where: CommunicationRequestWhereUniqueInput
    data: XOR<CommunicationRequestUpdateWithoutCrewInput, CommunicationRequestUncheckedUpdateWithoutCrewInput>
  }

  export type CommunicationRequestUpdateManyWithWhereWithoutCrewInput = {
    where: CommunicationRequestScalarWhereInput
    data: XOR<CommunicationRequestUpdateManyMutationInput, CommunicationRequestUncheckedUpdateManyWithoutCrewInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutCrewInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCrewInput, TaskUncheckedUpdateWithoutCrewInput>
    create: XOR<TaskCreateWithoutCrewInput, TaskUncheckedCreateWithoutCrewInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCrewInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCrewInput, TaskUncheckedUpdateWithoutCrewInput>
  }

  export type TaskUpdateManyWithWhereWithoutCrewInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCrewInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    crewId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    prioridad?: StringFilter<"Task"> | string
    estado?: StringFilter<"Task"> | string
    fecha_vencimiento?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type CrewCreateWithoutCrewWorkersInput = {
    id?: string
    name: string
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    project?: ProjectCreateNestedOneWithoutCrewsInput
    logs?: LogCreateNestedManyWithoutCrewInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutCrewInput
    communicationRequests?: CommunicationRequestCreateNestedManyWithoutCrewInput
    tasks?: TaskCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutCrewWorkersInput = {
    id?: string
    name: string
    projectId?: string | null
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    logs?: LogUncheckedCreateNestedManyWithoutCrewInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutCrewInput
    communicationRequests?: CommunicationRequestUncheckedCreateNestedManyWithoutCrewInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutCrewWorkersInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCrewWorkersInput, CrewUncheckedCreateWithoutCrewWorkersInput>
  }

  export type WorkerCreateWithoutCrewWorkersInput = {
    id?: string
    name: string
    rut?: string | null
    especialidad: string
    certificaciones?: string | null
    experiencia?: number | null
    disponibilidad?: boolean
    estado: string
    zona_preferencia?: string | null
    certificates?: CertificateCreateNestedManyWithoutWorkersInput
  }

  export type WorkerUncheckedCreateWithoutCrewWorkersInput = {
    id?: string
    name: string
    rut?: string | null
    especialidad: string
    certificaciones?: string | null
    experiencia?: number | null
    disponibilidad?: boolean
    estado: string
    zona_preferencia?: string | null
    certificates?: CertificateUncheckedCreateNestedManyWithoutWorkersInput
  }

  export type WorkerCreateOrConnectWithoutCrewWorkersInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutCrewWorkersInput, WorkerUncheckedCreateWithoutCrewWorkersInput>
  }

  export type CrewUpsertWithoutCrewWorkersInput = {
    update: XOR<CrewUpdateWithoutCrewWorkersInput, CrewUncheckedUpdateWithoutCrewWorkersInput>
    create: XOR<CrewCreateWithoutCrewWorkersInput, CrewUncheckedCreateWithoutCrewWorkersInput>
    where?: CrewWhereInput
  }

  export type CrewUpdateToOneWithWhereWithoutCrewWorkersInput = {
    where?: CrewWhereInput
    data: XOR<CrewUpdateWithoutCrewWorkersInput, CrewUncheckedUpdateWithoutCrewWorkersInput>
  }

  export type CrewUpdateWithoutCrewWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    project?: ProjectUpdateOneWithoutCrewsNestedInput
    logs?: LogUpdateManyWithoutCrewNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutCrewNestedInput
    communicationRequests?: CommunicationRequestUpdateManyWithoutCrewNestedInput
    tasks?: TaskUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutCrewWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    logs?: LogUncheckedUpdateManyWithoutCrewNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutCrewNestedInput
    communicationRequests?: CommunicationRequestUncheckedUpdateManyWithoutCrewNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type WorkerUpsertWithoutCrewWorkersInput = {
    update: XOR<WorkerUpdateWithoutCrewWorkersInput, WorkerUncheckedUpdateWithoutCrewWorkersInput>
    create: XOR<WorkerCreateWithoutCrewWorkersInput, WorkerUncheckedCreateWithoutCrewWorkersInput>
    where?: WorkerWhereInput
  }

  export type WorkerUpdateToOneWithWhereWithoutCrewWorkersInput = {
    where?: WorkerWhereInput
    data: XOR<WorkerUpdateWithoutCrewWorkersInput, WorkerUncheckedUpdateWithoutCrewWorkersInput>
  }

  export type WorkerUpdateWithoutCrewWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rut?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    certificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableIntFieldUpdateOperationsInput | number | null
    disponibilidad?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    zona_preferencia?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: CertificateUpdateManyWithoutWorkersNestedInput
  }

  export type WorkerUncheckedUpdateWithoutCrewWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rut?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    certificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableIntFieldUpdateOperationsInput | number | null
    disponibilidad?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    zona_preferencia?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: CertificateUncheckedUpdateManyWithoutWorkersNestedInput
  }

  export type CrewCreateWithoutLogsInput = {
    id?: string
    name: string
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    project?: ProjectCreateNestedOneWithoutCrewsInput
    crewWorkers?: CrewWorkerCreateNestedManyWithoutCrewInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutCrewInput
    communicationRequests?: CommunicationRequestCreateNestedManyWithoutCrewInput
    tasks?: TaskCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutLogsInput = {
    id?: string
    name: string
    projectId?: string | null
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    crewWorkers?: CrewWorkerUncheckedCreateNestedManyWithoutCrewInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutCrewInput
    communicationRequests?: CommunicationRequestUncheckedCreateNestedManyWithoutCrewInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutLogsInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutLogsInput, CrewUncheckedCreateWithoutLogsInput>
  }

  export type ProjectCreateWithoutLogsInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefe?: UserCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLogsInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefeId?: string | null
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLogsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLogsInput, ProjectUncheckedCreateWithoutLogsInput>
  }

  export type UserCreateWithoutLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutJefeInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    requests?: CommunicationRequestCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutJefeInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    requests?: CommunicationRequestUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type CrewUpsertWithoutLogsInput = {
    update: XOR<CrewUpdateWithoutLogsInput, CrewUncheckedUpdateWithoutLogsInput>
    create: XOR<CrewCreateWithoutLogsInput, CrewUncheckedCreateWithoutLogsInput>
    where?: CrewWhereInput
  }

  export type CrewUpdateToOneWithWhereWithoutLogsInput = {
    where?: CrewWhereInput
    data: XOR<CrewUpdateWithoutLogsInput, CrewUncheckedUpdateWithoutLogsInput>
  }

  export type CrewUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    project?: ProjectUpdateOneWithoutCrewsNestedInput
    crewWorkers?: CrewWorkerUpdateManyWithoutCrewNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutCrewNestedInput
    communicationRequests?: CommunicationRequestUpdateManyWithoutCrewNestedInput
    tasks?: TaskUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    crewWorkers?: CrewWorkerUncheckedUpdateManyWithoutCrewNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutCrewNestedInput
    communicationRequests?: CommunicationRequestUncheckedUpdateManyWithoutCrewNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type ProjectUpsertWithoutLogsInput = {
    update: XOR<ProjectUpdateWithoutLogsInput, ProjectUncheckedUpdateWithoutLogsInput>
    create: XOR<ProjectCreateWithoutLogsInput, ProjectUncheckedCreateWithoutLogsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLogsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLogsInput, ProjectUncheckedUpdateWithoutLogsInput>
  }

  export type ProjectUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefe?: UserUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefeId?: NullableStringFieldUpdateOperationsInput | string | null
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutJefeNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    requests?: CommunicationRequestUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutJefeNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    requests?: CommunicationRequestUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type MaterialRequestCreateWithoutMaterialInput = {
    id?: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutMaterialRequestsInput
    crew: CrewCreateNestedOneWithoutMaterialRequestsInput
  }

  export type MaterialRequestUncheckedCreateWithoutMaterialInput = {
    id?: string
    projectId: string
    crewId: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt?: Date | string
  }

  export type MaterialRequestCreateOrConnectWithoutMaterialInput = {
    where: MaterialRequestWhereUniqueInput
    create: XOR<MaterialRequestCreateWithoutMaterialInput, MaterialRequestUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialRequestCreateManyMaterialInputEnvelope = {
    data: MaterialRequestCreateManyMaterialInput | MaterialRequestCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type MaterialRequestUpsertWithWhereUniqueWithoutMaterialInput = {
    where: MaterialRequestWhereUniqueInput
    update: XOR<MaterialRequestUpdateWithoutMaterialInput, MaterialRequestUncheckedUpdateWithoutMaterialInput>
    create: XOR<MaterialRequestCreateWithoutMaterialInput, MaterialRequestUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialRequestUpdateWithWhereUniqueWithoutMaterialInput = {
    where: MaterialRequestWhereUniqueInput
    data: XOR<MaterialRequestUpdateWithoutMaterialInput, MaterialRequestUncheckedUpdateWithoutMaterialInput>
  }

  export type MaterialRequestUpdateManyWithWhereWithoutMaterialInput = {
    where: MaterialRequestScalarWhereInput
    data: XOR<MaterialRequestUpdateManyMutationInput, MaterialRequestUncheckedUpdateManyWithoutMaterialInput>
  }

  export type MaterialCreateWithoutRequestsInput = {
    id?: string
    name: string
    descripcion?: string | null
    stock: number
    unidad: string
    precio: number
  }

  export type MaterialUncheckedCreateWithoutRequestsInput = {
    id?: string
    name: string
    descripcion?: string | null
    stock: number
    unidad: string
    precio: number
  }

  export type MaterialCreateOrConnectWithoutRequestsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutRequestsInput, MaterialUncheckedCreateWithoutRequestsInput>
  }

  export type ProjectCreateWithoutMaterialRequestsInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefe?: UserCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMaterialRequestsInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefeId?: string | null
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMaterialRequestsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMaterialRequestsInput, ProjectUncheckedCreateWithoutMaterialRequestsInput>
  }

  export type CrewCreateWithoutMaterialRequestsInput = {
    id?: string
    name: string
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    project?: ProjectCreateNestedOneWithoutCrewsInput
    crewWorkers?: CrewWorkerCreateNestedManyWithoutCrewInput
    logs?: LogCreateNestedManyWithoutCrewInput
    communicationRequests?: CommunicationRequestCreateNestedManyWithoutCrewInput
    tasks?: TaskCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutMaterialRequestsInput = {
    id?: string
    name: string
    projectId?: string | null
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    crewWorkers?: CrewWorkerUncheckedCreateNestedManyWithoutCrewInput
    logs?: LogUncheckedCreateNestedManyWithoutCrewInput
    communicationRequests?: CommunicationRequestUncheckedCreateNestedManyWithoutCrewInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutMaterialRequestsInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutMaterialRequestsInput, CrewUncheckedCreateWithoutMaterialRequestsInput>
  }

  export type MaterialUpsertWithoutRequestsInput = {
    update: XOR<MaterialUpdateWithoutRequestsInput, MaterialUncheckedUpdateWithoutRequestsInput>
    create: XOR<MaterialCreateWithoutRequestsInput, MaterialUncheckedCreateWithoutRequestsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutRequestsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutRequestsInput, MaterialUncheckedUpdateWithoutRequestsInput>
  }

  export type MaterialUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    unidad?: StringFieldUpdateOperationsInput | string
    precio?: FloatFieldUpdateOperationsInput | number
  }

  export type MaterialUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    unidad?: StringFieldUpdateOperationsInput | string
    precio?: FloatFieldUpdateOperationsInput | number
  }

  export type ProjectUpsertWithoutMaterialRequestsInput = {
    update: XOR<ProjectUpdateWithoutMaterialRequestsInput, ProjectUncheckedUpdateWithoutMaterialRequestsInput>
    create: XOR<ProjectCreateWithoutMaterialRequestsInput, ProjectUncheckedCreateWithoutMaterialRequestsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMaterialRequestsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMaterialRequestsInput, ProjectUncheckedUpdateWithoutMaterialRequestsInput>
  }

  export type ProjectUpdateWithoutMaterialRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefe?: UserUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMaterialRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefeId?: NullableStringFieldUpdateOperationsInput | string | null
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CrewUpsertWithoutMaterialRequestsInput = {
    update: XOR<CrewUpdateWithoutMaterialRequestsInput, CrewUncheckedUpdateWithoutMaterialRequestsInput>
    create: XOR<CrewCreateWithoutMaterialRequestsInput, CrewUncheckedCreateWithoutMaterialRequestsInput>
    where?: CrewWhereInput
  }

  export type CrewUpdateToOneWithWhereWithoutMaterialRequestsInput = {
    where?: CrewWhereInput
    data: XOR<CrewUpdateWithoutMaterialRequestsInput, CrewUncheckedUpdateWithoutMaterialRequestsInput>
  }

  export type CrewUpdateWithoutMaterialRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    project?: ProjectUpdateOneWithoutCrewsNestedInput
    crewWorkers?: CrewWorkerUpdateManyWithoutCrewNestedInput
    logs?: LogUpdateManyWithoutCrewNestedInput
    communicationRequests?: CommunicationRequestUpdateManyWithoutCrewNestedInput
    tasks?: TaskUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutMaterialRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    crewWorkers?: CrewWorkerUncheckedUpdateManyWithoutCrewNestedInput
    logs?: LogUncheckedUpdateManyWithoutCrewNestedInput
    communicationRequests?: CommunicationRequestUncheckedUpdateManyWithoutCrewNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutJefeInput
    logs?: LogCreateNestedManyWithoutResponsableInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    requests?: CommunicationRequestCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutJefeInput
    logs?: LogUncheckedCreateNestedManyWithoutResponsableInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    requests?: CommunicationRequestUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutJefeInput
    logs?: LogCreateNestedManyWithoutResponsableInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    requests?: CommunicationRequestCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutJefeInput
    logs?: LogUncheckedCreateNestedManyWithoutResponsableInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    requests?: CommunicationRequestUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutJefeNestedInput
    logs?: LogUpdateManyWithoutResponsableNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    requests?: CommunicationRequestUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutJefeNestedInput
    logs?: LogUncheckedUpdateManyWithoutResponsableNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    requests?: CommunicationRequestUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutJefeNestedInput
    logs?: LogUpdateManyWithoutResponsableNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    requests?: CommunicationRequestUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutJefeNestedInput
    logs?: LogUncheckedUpdateManyWithoutResponsableNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    requests?: CommunicationRequestUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutRequestsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutJefeInput
    logs?: LogCreateNestedManyWithoutResponsableInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutRequestsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutJefeInput
    logs?: LogUncheckedCreateNestedManyWithoutResponsableInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestsInput, UserUncheckedCreateWithoutRequestsInput>
  }

  export type CrewCreateWithoutCommunicationRequestsInput = {
    id?: string
    name: string
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    project?: ProjectCreateNestedOneWithoutCrewsInput
    crewWorkers?: CrewWorkerCreateNestedManyWithoutCrewInput
    logs?: LogCreateNestedManyWithoutCrewInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutCrewInput
    tasks?: TaskCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutCommunicationRequestsInput = {
    id?: string
    name: string
    projectId?: string | null
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    crewWorkers?: CrewWorkerUncheckedCreateNestedManyWithoutCrewInput
    logs?: LogUncheckedCreateNestedManyWithoutCrewInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutCrewInput
    tasks?: TaskUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutCommunicationRequestsInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCommunicationRequestsInput, CrewUncheckedCreateWithoutCommunicationRequestsInput>
  }

  export type UserUpsertWithoutRequestsInput = {
    update: XOR<UserUpdateWithoutRequestsInput, UserUncheckedUpdateWithoutRequestsInput>
    create: XOR<UserCreateWithoutRequestsInput, UserUncheckedCreateWithoutRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequestsInput, UserUncheckedUpdateWithoutRequestsInput>
  }

  export type UserUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutJefeNestedInput
    logs?: LogUpdateManyWithoutResponsableNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutJefeNestedInput
    logs?: LogUncheckedUpdateManyWithoutResponsableNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CrewUpsertWithoutCommunicationRequestsInput = {
    update: XOR<CrewUpdateWithoutCommunicationRequestsInput, CrewUncheckedUpdateWithoutCommunicationRequestsInput>
    create: XOR<CrewCreateWithoutCommunicationRequestsInput, CrewUncheckedCreateWithoutCommunicationRequestsInput>
    where?: CrewWhereInput
  }

  export type CrewUpdateToOneWithWhereWithoutCommunicationRequestsInput = {
    where?: CrewWhereInput
    data: XOR<CrewUpdateWithoutCommunicationRequestsInput, CrewUncheckedUpdateWithoutCommunicationRequestsInput>
  }

  export type CrewUpdateWithoutCommunicationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    project?: ProjectUpdateOneWithoutCrewsNestedInput
    crewWorkers?: CrewWorkerUpdateManyWithoutCrewNestedInput
    logs?: LogUpdateManyWithoutCrewNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutCrewNestedInput
    tasks?: TaskUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutCommunicationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    crewWorkers?: CrewWorkerUncheckedUpdateManyWithoutCrewNestedInput
    logs?: LogUncheckedUpdateManyWithoutCrewNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutCrewNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type WorkerCreateWithoutCertificatesInput = {
    id?: string
    name: string
    rut?: string | null
    especialidad: string
    certificaciones?: string | null
    experiencia?: number | null
    disponibilidad?: boolean
    estado: string
    zona_preferencia?: string | null
    crewWorkers?: CrewWorkerCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUncheckedCreateWithoutCertificatesInput = {
    id?: string
    name: string
    rut?: string | null
    especialidad: string
    certificaciones?: string | null
    experiencia?: number | null
    disponibilidad?: boolean
    estado: string
    zona_preferencia?: string | null
    crewWorkers?: CrewWorkerUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type WorkerCreateOrConnectWithoutCertificatesInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutCertificatesInput, WorkerUncheckedCreateWithoutCertificatesInput>
  }

  export type WorkerUpsertWithWhereUniqueWithoutCertificatesInput = {
    where: WorkerWhereUniqueInput
    update: XOR<WorkerUpdateWithoutCertificatesInput, WorkerUncheckedUpdateWithoutCertificatesInput>
    create: XOR<WorkerCreateWithoutCertificatesInput, WorkerUncheckedCreateWithoutCertificatesInput>
  }

  export type WorkerUpdateWithWhereUniqueWithoutCertificatesInput = {
    where: WorkerWhereUniqueInput
    data: XOR<WorkerUpdateWithoutCertificatesInput, WorkerUncheckedUpdateWithoutCertificatesInput>
  }

  export type WorkerUpdateManyWithWhereWithoutCertificatesInput = {
    where: WorkerScalarWhereInput
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyWithoutCertificatesInput>
  }

  export type WorkerScalarWhereInput = {
    AND?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
    OR?: WorkerScalarWhereInput[]
    NOT?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
    id?: StringFilter<"Worker"> | string
    name?: StringFilter<"Worker"> | string
    rut?: StringNullableFilter<"Worker"> | string | null
    especialidad?: StringFilter<"Worker"> | string
    certificaciones?: StringNullableFilter<"Worker"> | string | null
    experiencia?: IntNullableFilter<"Worker"> | number | null
    disponibilidad?: BoolFilter<"Worker"> | boolean
    estado?: StringFilter<"Worker"> | string
    zona_preferencia?: StringNullableFilter<"Worker"> | string | null
  }

  export type ProjectCreateWithoutMilestonesInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefe?: UserCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMilestonesInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefeId?: string | null
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMilestonesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
  }

  export type ProjectUpsertWithoutMilestonesInput = {
    update: XOR<ProjectUpdateWithoutMilestonesInput, ProjectUncheckedUpdateWithoutMilestonesInput>
    create: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMilestonesInput, ProjectUncheckedUpdateWithoutMilestonesInput>
  }

  export type ProjectUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefe?: UserUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefeId?: NullableStringFieldUpdateOperationsInput | string | null
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CrewCreateWithoutTasksInput = {
    id?: string
    name: string
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    project?: ProjectCreateNestedOneWithoutCrewsInput
    crewWorkers?: CrewWorkerCreateNestedManyWithoutCrewInput
    logs?: LogCreateNestedManyWithoutCrewInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutCrewInput
    communicationRequests?: CommunicationRequestCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    projectId?: string | null
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
    crewWorkers?: CrewWorkerUncheckedCreateNestedManyWithoutCrewInput
    logs?: LogUncheckedCreateNestedManyWithoutCrewInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutCrewInput
    communicationRequests?: CommunicationRequestUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutTasksInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutTasksInput, CrewUncheckedCreateWithoutTasksInput>
  }

  export type CrewUpsertWithoutTasksInput = {
    update: XOR<CrewUpdateWithoutTasksInput, CrewUncheckedUpdateWithoutTasksInput>
    create: XOR<CrewCreateWithoutTasksInput, CrewUncheckedCreateWithoutTasksInput>
    where?: CrewWhereInput
  }

  export type CrewUpdateToOneWithWhereWithoutTasksInput = {
    where?: CrewWhereInput
    data: XOR<CrewUpdateWithoutTasksInput, CrewUncheckedUpdateWithoutTasksInput>
  }

  export type CrewUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    project?: ProjectUpdateOneWithoutCrewsNestedInput
    crewWorkers?: CrewWorkerUpdateManyWithoutCrewNestedInput
    logs?: LogUpdateManyWithoutCrewNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutCrewNestedInput
    communicationRequests?: CommunicationRequestUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    crewWorkers?: CrewWorkerUncheckedUpdateManyWithoutCrewNestedInput
    logs?: LogUncheckedUpdateManyWithoutCrewNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutCrewNestedInput
    communicationRequests?: CommunicationRequestUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type ProjectCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefe?: UserCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
    jefeId?: string | null
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    materialRequests?: MaterialRequestUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAuditLogsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAuditLogsInput, ProjectUncheckedCreateWithoutAuditLogsInput>
  }

  export type ProjectUpsertWithoutAuditLogsInput = {
    update: XOR<ProjectUpdateWithoutAuditLogsInput, ProjectUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ProjectCreateWithoutAuditLogsInput, ProjectUncheckedCreateWithoutAuditLogsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAuditLogsInput, ProjectUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ProjectUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefe?: UserUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    jefeId?: NullableStringFieldUpdateOperationsInput | string | null
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyJefeInput = {
    id?: string
    name: string
    tipo_obra: string
    complejidad: string
    duracion_estimada?: number | null
    fecha_inicio?: Date | string | null
    fecha_termino?: Date | string | null
    zona_trabajo: string
    estado: string
    presupuesto?: number | null
    supervisor?: string | null
    descripcion_tecnica?: string | null
  }

  export type LogCreateManyResponsableInput = {
    id?: string
    crewId: string
    projectId: string
    descripcion?: string | null
    incidentes?: string | null
    consumo_materiales?: string | null
    avance?: string | null
    fecha?: Date | string
    actividades?: string | null
    materiales_consumidos?: string | null
    tiempos_trabajo?: string | null
    observaciones?: string | null
    estado_herramientas?: string | null
  }

  export type MessageCreateManySenderInput = {
    id?: string
    receiverId: string
    content: string
    conversationId?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateManyReceiverInput = {
    id?: string
    senderId: string
    content: string
    conversationId?: string | null
    createdAt?: Date | string
  }

  export type CommunicationRequestCreateManySenderInput = {
    id?: string
    requestType: $Enums.RequestType
    description: string
    urgency?: string
    crewId: string
    estado?: $Enums.RequestStatus
    respuesta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateWithoutJefeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    crews?: CrewUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutJefeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutJefeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tipo_obra?: StringFieldUpdateOperationsInput | string
    complejidad?: StringFieldUpdateOperationsInput | string
    duracion_estimada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zona_trabajo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    presupuesto?: NullableFloatFieldUpdateOperationsInput | number | null
    supervisor?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion_tecnica?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUpdateWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
    crew?: CrewUpdateOneRequiredWithoutLogsNestedInput
    project?: ProjectUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationRequestUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    description?: StringFieldUpdateOperationsInput | string
    urgency?: StringFieldUpdateOperationsInput | string
    estado?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crew?: CrewUpdateOneRequiredWithoutCommunicationRequestsNestedInput
  }

  export type CommunicationRequestUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    description?: StringFieldUpdateOperationsInput | string
    urgency?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    estado?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationRequestUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    description?: StringFieldUpdateOperationsInput | string
    urgency?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    estado?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewCreateManyProjectInput = {
    id?: string
    name: string
    fecha_inicio?: Date | string | null
    estado: $Enums.CrewState
    zona_trabajo?: string | null
    fecha_plazo?: Date | string | null
    cantidad_trabajadores?: number | null
  }

  export type MaterialRequestCreateManyProjectInput = {
    id?: string
    materialId: string
    crewId: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt?: Date | string
  }

  export type LogCreateManyProjectInput = {
    id?: string
    crewId: string
    descripcion?: string | null
    incidentes?: string | null
    consumo_materiales?: string | null
    avance?: string | null
    fecha?: Date | string
    responsableId: string
    actividades?: string | null
    materiales_consumidos?: string | null
    tiempos_trabajo?: string | null
    observaciones?: string | null
    estado_herramientas?: string | null
  }

  export type MilestoneCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    targetDate: Date | string
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyProjectInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId?: string | null
    changes?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type CrewUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    crewWorkers?: CrewWorkerUpdateManyWithoutCrewNestedInput
    logs?: LogUpdateManyWithoutCrewNestedInput
    materialRequests?: MaterialRequestUpdateManyWithoutCrewNestedInput
    communicationRequests?: CommunicationRequestUpdateManyWithoutCrewNestedInput
    tasks?: TaskUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
    crewWorkers?: CrewWorkerUncheckedUpdateManyWithoutCrewNestedInput
    logs?: LogUncheckedUpdateManyWithoutCrewNestedInput
    materialRequests?: MaterialRequestUncheckedUpdateManyWithoutCrewNestedInput
    communicationRequests?: CommunicationRequestUncheckedUpdateManyWithoutCrewNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumCrewStateFieldUpdateOperationsInput | $Enums.CrewState
    zona_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_plazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad_trabajadores?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MaterialRequestUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutRequestsNestedInput
    crew?: CrewUpdateOneRequiredWithoutMaterialRequestsNestedInput
  }

  export type MaterialRequestUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
    crew?: CrewUpdateOneRequiredWithoutLogsNestedInput
    responsable?: UserUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    responsableId?: StringFieldUpdateOperationsInput | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    responsableId?: StringFieldUpdateOperationsInput | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MilestoneUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewWorkerCreateManyWorkerInput = {
    id?: string
    crewId: string
    role: string
    fecha_asignacion?: Date | string
  }

  export type CrewWorkerUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    fecha_asignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    crew?: CrewUpdateOneRequiredWithoutCrewWorkersNestedInput
  }

  export type CrewWorkerUncheckedUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    fecha_asignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewWorkerUncheckedUpdateManyWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    fecha_asignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewWorkerCreateManyCrewInput = {
    id?: string
    workerId: string
    role: string
    fecha_asignacion?: Date | string
  }

  export type LogCreateManyCrewInput = {
    id?: string
    projectId: string
    descripcion?: string | null
    incidentes?: string | null
    consumo_materiales?: string | null
    avance?: string | null
    fecha?: Date | string
    responsableId: string
    actividades?: string | null
    materiales_consumidos?: string | null
    tiempos_trabajo?: string | null
    observaciones?: string | null
    estado_herramientas?: string | null
  }

  export type MaterialRequestCreateManyCrewInput = {
    id?: string
    materialId: string
    projectId: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt?: Date | string
  }

  export type CommunicationRequestCreateManyCrewInput = {
    id?: string
    senderId: string
    requestType: $Enums.RequestType
    description: string
    urgency?: string
    estado?: $Enums.RequestStatus
    respuesta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyCrewInput = {
    id?: string
    title: string
    description?: string | null
    prioridad?: string
    estado?: string
    fecha_vencimiento?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrewWorkerUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    fecha_asignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    worker?: WorkerUpdateOneRequiredWithoutCrewWorkersNestedInput
  }

  export type CrewWorkerUncheckedUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    fecha_asignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewWorkerUncheckedUpdateManyWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    fecha_asignacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutLogsNestedInput
    responsable?: UserUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    responsableId?: StringFieldUpdateOperationsInput | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    incidentes?: NullableStringFieldUpdateOperationsInput | string | null
    consumo_materiales?: NullableStringFieldUpdateOperationsInput | string | null
    avance?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    responsableId?: StringFieldUpdateOperationsInput | string
    actividades?: NullableStringFieldUpdateOperationsInput | string | null
    materiales_consumidos?: NullableStringFieldUpdateOperationsInput | string | null
    tiempos_trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado_herramientas?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialRequestUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutRequestsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMaterialRequestsNestedInput
  }

  export type MaterialRequestUncheckedUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestUncheckedUpdateManyWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationRequestUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    description?: StringFieldUpdateOperationsInput | string
    urgency?: StringFieldUpdateOperationsInput | string
    estado?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutRequestsNestedInput
  }

  export type CommunicationRequestUncheckedUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    description?: StringFieldUpdateOperationsInput | string
    urgency?: StringFieldUpdateOperationsInput | string
    estado?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationRequestUncheckedUpdateManyWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    description?: StringFieldUpdateOperationsInput | string
    urgency?: StringFieldUpdateOperationsInput | string
    estado?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestCreateManyMaterialInput = {
    id?: string
    projectId: string
    crewId: string
    cantidad: number
    estado: $Enums.MaterialRequestState
    createdAt?: Date | string
  }

  export type MaterialRequestUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMaterialRequestsNestedInput
    crew?: CrewUpdateOneRequiredWithoutMaterialRequestsNestedInput
  }

  export type MaterialRequestUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialRequestUncheckedUpdateManyWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    estado?: EnumMaterialRequestStateFieldUpdateOperationsInput | $Enums.MaterialRequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rut?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    certificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableIntFieldUpdateOperationsInput | number | null
    disponibilidad?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    zona_preferencia?: NullableStringFieldUpdateOperationsInput | string | null
    crewWorkers?: CrewWorkerUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rut?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    certificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableIntFieldUpdateOperationsInput | number | null
    disponibilidad?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    zona_preferencia?: NullableStringFieldUpdateOperationsInput | string | null
    crewWorkers?: CrewWorkerUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateManyWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rut?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    certificaciones?: NullableStringFieldUpdateOperationsInput | string | null
    experiencia?: NullableIntFieldUpdateOperationsInput | number | null
    disponibilidad?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    zona_preferencia?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkerCountOutputTypeDefaultArgs instead
     */
    export type WorkerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewCountOutputTypeDefaultArgs instead
     */
    export type CrewCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialCountOutputTypeDefaultArgs instead
     */
    export type MaterialCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificateCountOutputTypeDefaultArgs instead
     */
    export type CertificateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkerDefaultArgs instead
     */
    export type WorkerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewDefaultArgs instead
     */
    export type CrewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewWorkerDefaultArgs instead
     */
    export type CrewWorkerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewWorkerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogDefaultArgs instead
     */
    export type LogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialDefaultArgs instead
     */
    export type MaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialRequestDefaultArgs instead
     */
    export type MaterialRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunicationRequestDefaultArgs instead
     */
    export type CommunicationRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunicationRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificateDefaultArgs instead
     */
    export type CertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MilestoneDefaultArgs instead
     */
    export type MilestoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MilestoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}